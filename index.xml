<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Showcase Template</title><link>https://nzone56.github.io/showcase/</link><description>Recent content in Introduction on Showcase Template</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://nzone56.github.io/showcase/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_1/illusions/coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_1/illusions/coloring/</guid><description>Illusions - Color Mixing # Explicación # El color es la impresión producida por un tono de luz en los órganos visuales, se trata de un fenómeno físico-químico donde cada color depende de la longitud de onda. En la siguiente animación podemos ver la mezcla aditiva de colores, en la parte izquierda, y la mezcla substractiva de colores en la parte derecha.
Intuitivamente podemos realizar la mezcla de los colores mediante la cantidad de luz perteneciente al espectro R(red), G(green), B(blue), produciendo todas las posible gamas y tonos, pero adicionalmente podemos sustraer colores aplicando un filtro, que se gradua mediante transparencia y que puede ser de color cyan que permite solo el paso de la luz verde y azul, el filtro magenta permite solo el paso de la luz roja y azul, y por último el filtro amarillo, que permite el paso de la luz roja y verde únicamente.</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_1/illusions/lilac_chaser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_1/illusions/lilac_chaser/</guid><description>Illusions - Lilac chaser # Consiste en unos discos de color borrosos alrededor de un punto central, donde en cada frame uno de estos discos desaparece y aparece luego el siguiente hace lo mismo en sentido de las agujas del reloj.
CODE const CANVAS_SIZE = 500; const DISTANCE = 200; function setup() { createCanvas(CANVAS_SIZE, CANVAS_SIZE); frameRate(10); colorPicker = createColorPicker(&amp;#34;#ee00ee&amp;#34;); colorPicker.position(10, height - 25); circleCountSlider = createSlider(12, 20, 12); circleCountSlider.position(width - 100, height - 20); circleCountSlider.</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_1/illusions/moire/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_1/illusions/moire/</guid><description>Illusions - Moiré # Explicación # Patrones de interferencia que pueden producirse cuando se superpone un patrón reglado opaco con huecos transparentes sobre otro patrón similar. CODE let xspeed = 2.3; let yspeed = 2.8; let xdirection = 1; let ydirection = 1; function setup() { createCanvas(700, 700); x1 = width/2; y1 = height/2; n = width/10; d = 50; x2 = width/2; y2 = height/2; } function moire(x,y,d,n){ for( i = 0;i&amp;lt;n;i++){ circle(x, y, d*i); strokeWeight(10); noFill(); } } function txt(){ textFont(&amp;#39;Georgia&amp;#39;); textSize(150); var w = textWidth(&amp;#34;MOIRÉ&amp;#34;); fill(0); fill(255); text(&amp;#34;MOIRÉ&amp;#34;, width/7.</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_1/illusions/stepping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_1/illusions/stepping/</guid><description> Illusions - Stepping # Explicación # Las diferencias de contraste entre el amarillo y el blanco y el negro y el azul permiten que se genere la ilusión optica en la que los bloques van dando pasos. Este efecto se ve reforzado cuando el experimento se hace a blanco y negro.
Oprima el mouse para quitar el fondo.
Oprima una tecla para pasar a blanco y negro. CODE function setup() { createCanvas(800, 400); frameRate(45) posX=0 colorA=color(255,255,0) colorB=color(25,25,112) bars=true blackWhite=false } function draw() { background(255); if(bars){ for (i =0;i&amp;lt;800;i=i+40){ fill(color(0)) rect(i, 0, 20, 400); } } noStroke() fill(colorA) rect(posX,140,120,40) fill(colorB) rect(posX,260,120,40) posX=posX+1 if(posX==680){ posX=0 } } function mousePressed() { if(bars==true){ bars=false }else{ bars=true } } function keyPressed(){ if(blackWhite==false){ colorA=color(255) colorB=color(0) blackWhite=true }else{ colorA=color(255,255,0) colorB=color(25,25,112) blackWhite=false } }</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_1/masking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_1/masking/</guid><description>Workshop - Masking # Kernel # In image processing, a kernel, convolution matrix, or mask is a small matrix used for blurring, sharpening, embossing, edge detection, and more. This is accomplished by doing a convolution between the kernel and an image.
Convolution # Convolution is the process of adding each element of the image to its local neighbors, weighted by the kernel. This is related to a form of mathematical convolution.</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_1/terrain_visualization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_1/terrain_visualization/</guid><description> Terrain Visualization #</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_2/Bresenhams-line-algorithm-rasterization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_2/Bresenhams-line-algorithm-rasterization/</guid><description>Bresenham&amp;rsquo;s line algorithm (rasterization) # Bresenham&amp;rsquo;s line algorithm is a line drawing algorithm that determines the points of an n-dimensional raster that should be selected in order to form a close approximation to a straight line between two points. It is commonly used to draw line primitives in a bitmap image (e.g. on a computer screen), as it uses only integer addition, subtraction and bit shifting, all of which are very cheap operations in commonly used computer instruction sets such as x86_64.</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_2/rubik/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_2/rubik/</guid><description>Rubik&amp;rsquo;s cube # Introduction # The Rubik&amp;rsquo;s cube is a 3x3x3 cube with 6 faces. Each face has 9 stickers, each sticker has a color. The cube can be rotated in 3 dimensions. The goal is to rotate the cube so that each face has the same color.
CODE const WIDTH = 500, HEIGHT = 500; const SIZE = WIDTH / 15; const MOVES = [ &amp;#34;U&amp;#34;, &amp;#34;U&amp;#39;&amp;#34;, &amp;#34;U2&amp;#34;, &amp;#34;D&amp;#34;, &amp;#34;D&amp;#39;&amp;#34;, &amp;#34;D2&amp;#34;, &amp;#34;R&amp;#34;, &amp;#34;R&amp;#39;&amp;#34;, &amp;#34;R2&amp;#34;, &amp;#34;L&amp;#34;, &amp;#34;L&amp;#39;&amp;#34;, &amp;#34;L2&amp;#34;, &amp;#34;F&amp;#34;, &amp;#34;F&amp;#39;&amp;#34;, &amp;#34;F2&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;B&amp;#39;&amp;#34;, &amp;#34;B2&amp;#34;, ]; const COLOR_MAP = { 1: [255], 2: [255, 255, 0], 3: [255, 0, 0], 4: [255, 128, 0], 5: [0, 255, 0], 6: [0, 0, 255], }; const KEY_MAP = { U: () =&amp;gt; turnFace(up, 0), &amp;#34;U&amp;#39;&amp;#34;: () =&amp;gt; { turnFace(up, 0); turnFace(up, 0); turnFace(up, 0); }, U2: () =&amp;gt; { turnFace(up, 0); turnFace(up, 0); }, D: () =&amp;gt; turnFace(down, 1), &amp;#34;D&amp;#39;&amp;#34;: () =&amp;gt; { turnFace(down, 1); turnFace(down, 1); turnFace(down, 1); }, D2: () =&amp;gt; { turnFace(down, 1); turnFace(down, 1); }, R: () =&amp;gt; turnFace(right, 2), &amp;#34;R&amp;#39;&amp;#34;: () =&amp;gt; { turnFace(right, 2); turnFace(right, 2); turnFace(right, 2); }, R2: () =&amp;gt; { turnFace(right, 2); turnFace(right, 2); }, L: () =&amp;gt; turnFace(left, 3), &amp;#34;L&amp;#39;&amp;#34;: () =&amp;gt; { turnFace(left, 3); turnFace(left, 3); turnFace(left, 3); }, L2: () =&amp;gt; { turnFace(left, 3); turnFace(left, 3); }, F: () =&amp;gt; turnFace(front, 4), &amp;#34;F&amp;#39;&amp;#34;: () =&amp;gt; { turnFace(front, 4); turnFace(front, 4); turnFace(front, 4); }, F2: () =&amp;gt; { turnFace(front, 4); turnFace(front, 4); }, B: () =&amp;gt; turnFace(back, 5), &amp;#34;B&amp;#39;&amp;#34;: () =&amp;gt; { turnFace(back, 5); turnFace(back, 5); turnFace(back, 5); }, B2: () =&amp;gt; { turnFace(back, 5); turnFace(back, 5); }, }; let up, down, right, left, front, back; let easycam; // eslint-disable-next-line no-unused-vars function setup() { createCanvas(WIDTH, HEIGHT, WEBGL); setAttributes(&amp;#34;antialias&amp;#34;, true); initPos(); easycam = createEasyCam(); easycam.</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_2/skeleton/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_2/skeleton/</guid><description>Visualization of an skeleton render # Allows the visualization of a 3d model of a skeleton with its individual parts as separate .obj files.
Possible applications:
Medical image analysis Position animation Anatomical atlas Modelo original obtenido de: https://sketchfab.com/3d-models/low-poly-skeleton-4866bd05df2d4febba463295cd24b564</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_3/ascii_art/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_3/ascii_art/</guid><description>Ascii art # CODE const WIDTH = 630, HEIGHT = 630; const density = &amp;#34;Ñ@#W$9876543210?!abc;:+=,._ &amp;#34;; let media; let photo; // eslint-disable-next-line no-unused-vars function setup() { createCanvas(WIDTH, HEIGHT); scaleSlider = createSlider(0.1, 0.2, 0.1, 0.02); scaleSlider.position(width - 110, height - 30); scaleSlider.style(&amp;#34;width&amp;#34;, &amp;#34;100px&amp;#34;); scaleSliderLabel = createDiv(&amp;#34;Scale&amp;#34;); scaleSliderLabel.position(width - 110, height - 50); scaleSliderLabel.style(&amp;#34;color&amp;#34;, &amp;#34;#fff&amp;#34;); modeSelector = createSelect(); modeSelector.position(10, height - 40); modeSelector.option(&amp;#34;original&amp;#34;); modeSelector.option(&amp;#34;pixelated&amp;#34;); modeSelector.option(&amp;#34;colored ascii&amp;#34;); modeSelector.option(&amp;#34;ascii&amp;#34;); modeSelector.option(&amp;#34;BW&amp;#34;); modeSelector.selected(&amp;#34;ascii&amp;#34;); modeSelector.changed(() =&amp;gt; { if (modeSelector.</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_3/coloring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_3/coloring/</guid><description>Shaders - Coloring # CMY and RGB Color Models # Explicación # CODE cmy = false function setup() { // shaders require WEBGL mode to work createCanvas(400, 400, WEBGL); setColor(); randomizeTriangle(); } function draw() { background(0); beginShape(TRIANGLES); fill(r); vertex(v1.x*200, v1.y*200); fill(g); vertex(v2.x*200, v2.y*200); fill(b); vertex(v3.x*200, v3.y*200); endShape(); } function keyPressed() { if (key == &amp;#39;c&amp;#39;) { cmy = !cmy; setColor(); console.log(cmy) } if (key == &amp;#39;r&amp;#39;) { randomizeTriangle(); } } function randomizeTriangle(){ v1 = p5.</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_3/image_processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_3/image_processing/</guid><description>Image Processing # Exercise # Implement an image / video processing app supporting different masks, including other kernel sizes different than 3x3, and:
A region-of-interest base tool to selectively apply a given mask.Hint: circular regions around the mouse pointer are handy and quite simple to implement by means of glsl distance. A magnifier tool. Requires a bit of research. For instance, look for it in shadertoy. Integrate luma and other coloring brightness tools.</description></item><item><title/><link>https://nzone56.github.io/showcase/docs/workshop_3/video_pixelator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nzone56.github.io/showcase/docs/workshop_3/video_pixelator/</guid><description>Video Circle Pixelator # A pixel is generally thought of as the smallest single component of a digital image. However, the definition is highly context-sensitive. For example, there can be &amp;ldquo;printed pixels&amp;rdquo; in a page, or pixels carried by electronic signals, or represented by digital values, or pixels on a display device, or pixels in a digital camera (photosensor elements). This list is not exhaustive and, depending on context, synonyms include pel, sample, byte, bit, dot, and spot.</description></item></channel></rss>