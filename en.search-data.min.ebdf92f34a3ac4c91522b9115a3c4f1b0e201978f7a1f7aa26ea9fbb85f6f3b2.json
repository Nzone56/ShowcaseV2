[{"id":0,"href":"/showcase/docs/our_team/","title":"Our Team","section":"Docs","content":" Our Team 💻 # Name Email Github Diego Alejandro Irreño Torres dirreno@unal.edu.co dirreno Julian Andres Pereira Plata jpereirap@unal.edu.co Nzone56 Luiggi Alexander Alvarez Velasquez luaalvarezve@unal.edu.co Darkluiggi Daniel Santiago Mendoza Morales dmendozam@unal.edu.co dmendozam Sebastian Garnica Quiroz sgarnicaq@unal.edu.co SGman98 Sonny Ernesto Niño Ramirez snino@unal.edu.co SonnyNR Facultad de Ingeniería Universidad Nacional de Colombia 2022-2 "},{"id":1,"href":"/showcase/docs/workshop_1/","title":"Workshop 1","section":"Docs","content":" Workshop 1 # Workshop # Illusions # Study, implement and discuss possible applications of some known visual phenomena and optical illusions. Masking # Implement an image processing web app supporting different image kernels and supporting:\nImage histogram visualization. Different lightness (coloring brightness) tools. Exercises # Coloring # Let rgb1 and rgb2 be two rgb colors. What rgb1 * rgb2 would mean? Spatial coherence # Research spatial coherence visual applications. Terrain visualization # Develop a terrain visualization application. "},{"id":2,"href":"/showcase/docs/workshop_1/coloring/","title":"Coloring","section":"Workshop 1","content":" Illusions - Color Mixing # Explicación # El color es la impresión producida por un tono de luz en los órganos visuales, es decir se trata de una percepción visual. En la siguiente animación podemos ver la mezcla aditiva de colores, en la parte izquierda, y la mezcla substractiva de colores en la parte derecha.\nIntuitivamente podemos mezclar los colores, produciendo todas las posibilidades de gamas y tonos, pero adicionalmente podemos sustraer colores aplicando un filtro, que puede ser de color cyan que permite solo el paso de la luz verde y azul, el filtro magenta permite solo el paso de la luz roja y azul, y por último el filtro amarillo, que permite el paso de la luz roja y verde únicamente.\nCODE function setup() { createCanvas(640, 340); redVal = 0; redUp = true; blueVal = 0; blueUp = true; greenVal = 0; greenUp = true; cyanVal = 0; cyanUp = true; magentaVal = 0; magentaUp = true yellowVal = 0; yellowUp = true; } function draw() { background(220); noStroke(); if(redUp){ redVal = redVal + 1; fill(redVal, 0,0) redUp = redVal \u0026gt; 255 ? false : true; }else{ redVal = redVal - 1; fill(redVal, 0,0) redUp = redVal \u0026lt; 0 ? true : false; } circle(140,100,160) if(greenUp){ greenVal = greenVal +1.5; fill(0, greenVal,0) greenUp = greenVal \u0026gt; 255 ? false : true; }else{ greenVal = greenVal - 1.5; fill(0,greenVal,0) greenUp = greenVal \u0026lt; 0 ? true : false; } circle(170,160,160) if(blueUp){ blueVal = blueVal+2; fill(0, 0, blueVal) blueUp = blueVal \u0026gt; 255 ? false : true; }else{ blueVal = blueVal-2; fill(0,0, blueVal) blueUp = blueVal \u0026lt; 0 ? true : false; } circle(100,160, 160); fill(redVal, 0,blueVal); arc(140,100, 160, 160, 2.07,3.33); arc(100,160, 160, 160, 4.2, 5.39); fill(redVal, greenVal,0); arc(140,100, 160, 160, 6.25, 1.07); arc(170,160, 160, 160, 4.2, 5.39); fill( 0, greenVal, blueVal); arc(170,160, 160, 160, 2.02, PI); arc(100,160, 160, 160, 0, 1.12); fill( redVal, greenVal, blueVal); arc(170,160, 160, 160, 3.11, 4.25); arc(140,100, 160, 160, 1.07, 2.24); arc(100,160, 160, 160, 5.16, 0.125); beginShape(); vertex(260, 120); vertex(290, 120); vertex(290, 150); vertex(260, 150); endShape(CLOSE); beginShape(); vertex(290, 160); vertex(320, 130); vertex(290, 110); endShape(CLOSE); if(cyanUp){ cyanVal = cyanVal+0.5; cyanUp = cyanVal \u0026gt; 255 ? false : true; }else{ cyanVal = cyanVal-0.5; cyanUp = cyanVal \u0026lt; 0 ? true : false; } stroke(0,0,0) fill(0,255,255, cyanVal); beginShape(); vertex(340, 100); vertex(350, 100); vertex(350, 180); vertex(340, 180); endShape(CLOSE); if(magentaUp){ magentaVal = magentaVal+2; magentaUp = magentaVal \u0026gt; 255 ? false : true; }else{ magentaVal = magentaVal-2; magentaUp = magentaVal \u0026lt; 0 ? true : false; } fill(255,0,255, magentaVal); beginShape(); vertex(380, 100); vertex(390, 100); vertex(390, 180); vertex(380, 180); endShape(CLOSE); if(yellowUp){ yellowVal = yellowVal+1; yellowUp = yellowVal \u0026gt; 255 ? false : true; }else{ yellowVal = yellowVal-1; yellowUp = yellowVal \u0026lt; 0 ? true : false; } fill(255,255,0, yellowVal); beginShape(); vertex(420, 100); vertex(430, 100); vertex(430, 180); vertex(420, 180); endShape(CLOSE); fill( redVal-cyanVal, greenVal-magentaVal, blueVal-yellowVal); circle(520,150,120); } "},{"id":3,"href":"/showcase/docs/workshop_1/illusions/","title":"Illusions","section":"Workshop 1","content":" Visual illusions # Introduction to main illusions used throughout the ebook template which may be classified into two groups: visual artifacts that should be avoided, such as mach bands; and, visual algorithms and applications that may strategically adopted them, such as spatial coherence.\nIllusions workshop # Study, implement and discuss possible applications of some known visual phenomena and optical illusions. From https://visualcomputing.github.io/docs/illusions/\n"},{"id":4,"href":"/showcase/docs/workshop_1/illusions/lilac_chaser/","title":"Lilac Chaser","section":"Illusions","content":" Illusions - Lilac chaser # Consiste en unos discos de color borrosos alrededor de un punto central, donde en cada frame uno de estos discos desaparece y aparece luego el siguiente hace lo mismo en sentido de las agujas del reloj.\nCODE const CANVAS_SIZE = 500; const DISTANCE = 200; function setup() { createCanvas(CANVAS_SIZE, CANVAS_SIZE); frameRate(10); colorPicker = createColorPicker(\u0026#34;#ee00ee\u0026#34;); colorPicker.position(10, height - 25); circleCountSlider = createSlider(12, 20, 12); circleCountSlider.position(width - 100, height - 20); circleCountSlider.style(\u0026#34;width\u0026#34;, \u0026#34;100px\u0026#34;); blurToggle = createButton(\u0026#34;Blur\u0026#34;); blurToggle.position(width - 30, 10); blurToggle.mousePressed(() =\u0026gt; (blur = !blur)); } function draw() { const CIRCLE_COUNT = circleCountSlider.value(); const CIRCLE_RADIUS = DISTANCE / (CIRCLE_COUNT / 3); if (blur) drawingContext.filter = \u0026#34;blur(20px)\u0026#34;; background(150); noStroke(); fill(colorPicker.color()); for (let i = 0; i \u0026lt; CIRCLE_COUNT; i++) { if (i === frameCount % CIRCLE_COUNT) continue; // skip one circle const angle = (i / CIRCLE_COUNT) * TWO_PI; const x = CANVAS_SIZE / 2 + DISTANCE * cos(angle); const y = CANVAS_SIZE / 2 + DISTANCE * sin(angle); circle(x, y, CIRCLE_RADIUS); } drawingContext.filter = \u0026#34;none\u0026#34;; // cross cursor in the middle stroke(0); translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2); line(-10, 0, 10, 0); line(0, -10, 0, 10); } Explicación # En esta ilusión se pueden observar 3 cosas:\nLa sucesión de la desaparición de los discos aparenta crear un movimiento. Esto es debido a que el ojo humano es capaz de interpretar una sucesión de imágenes y reconocerlas como un movimiento fluido llenando los huecos entre estas.\nEl disco que desaparece toma un color. Esto se debe al efecto de la persistencia de la visión, que es la capacidad del ojo humano de mantener una imagen en la retina durante un tiempo, en este caso la imagen esta en alto contraste con el fondo, por lo que el ojo genera una imagen remanente negativa con el color complementario a los discos.\nLos demás discos comienzan a desaparecer. El desvanecimiento de los discos se debe a que al estar enfocados en un punto por mucho tiempo el cerebro comienza a ignorar aquella información que no sea necesaria, en este caso los discos están borrosos y fuera del punto de enfoque, por lo que el cerebro los ignora.\n"},{"id":5,"href":"/showcase/docs/workshop_1/illusions/moire/","title":"Moire","section":"Illusions","content":" Illusions - Moiré # Explicación # Patrones de interferencia que pueden producirse cuando se superpone un patrón reglado opaco con huecos transparentes sobre otro patrón similar. CODE let xspeed = 2.3; let yspeed = 2.8; let xdirection = 1; let ydirection = 1; function setup() { createCanvas(700, 700); x1 = width/2; y1 = height/2; n = width/10; d = 50; x2 = width/2; y2 = height/2; } function moire(x,y,d,n){ for( i = 0;i\u0026lt;n;i++){ circle(x, y, d*i); strokeWeight(10); noFill(); } } function txt(){ textFont(\u0026#39;Georgia\u0026#39;); textSize(150); var w = textWidth(\u0026#34;MOIRÉ\u0026#34;); fill(0); fill(255); text(\u0026#34;MOIRÉ\u0026#34;, width/7.5, height/1.75); } function draw() { background(color(\u0026#34;rgb(235,0,0)\u0026#34;)); x2 = x2 + xspeed * xdirection; y2 = y2 + yspeed * ydirection; txt() if (x2 \u0026gt; width || x2 \u0026lt; 0) { xdirection *= -1; } if (y2 \u0026gt; height || y2 \u0026lt; 0) { ydirection *= -1; } m1 = moire(x1,y1,d,n); m2 = moire(x2,y2,d,n); } "},{"id":6,"href":"/showcase/docs/workshop_1/illusions/stepping/","title":"Stepping","section":"Illusions","content":" Illusions - Stepping # Explicación # Las diferencias de contraste entre el amarillo y el blanco y el negro y el azul permiten que se genere la ilusión optica en la que los bloques van dando pasos. Este efecto se ve reforzado cuando el experimento se hace a blanco y negro.\nOprima el mouse para quitar el fondo.\nOprima una tecla para pasar a blanco y negro. CODE function setup() { createCanvas(800, 400); frameRate(45) posX=0 colorA=color(255,255,0) colorB=color(25,25,112) bars=true blackWhite=false } function draw() { background(255); if(bars){ for (i =0;i\u0026lt;800;i=i+40){ fill(color(0)) rect(i, 0, 20, 400); } } noStroke() fill(colorA) rect(posX,140,120,40) fill(colorB) rect(posX,260,120,40) posX=posX+1 if(posX==680){ posX=0 } } function mousePressed() { if(bars==true){ bars=false }else{ bars=true } } function keyPressed(){ if(blackWhite==false){ colorA=color(255) colorB=color(0) blackWhite=true }else{ colorA=color(255,255,0) colorB=color(25,25,112) blackWhite=false } } "},{"id":7,"href":"/showcase/docs/workshop_1/masking/","title":"Masking","section":"Workshop 1","content":" Workshop - Masking # Kernel # In image processing, a kernel, convolution matrix, or mask is a small matrix used for blurring, sharpening, embossing, edge detection, and more. This is accomplished by doing a convolution between the kernel and an image.\nConvolution # Convolution is the process of adding each element of the image to its local neighbors, weighted by the kernel. This is related to a form of mathematical convolution. The matrix operation being performed—convolution—is not traditional matrix multiplication, despite being similarly denoted by *.\nFor each 3x3 block of pixels in the original image , we multiply each pixel by the corresponding entry of the kernel and then take the sum. That sum becomes a new pixel in the result image.\nOne subtlety of this process is what to do along the edges of the image. For example, the top left corner of the input image only has three neighbors. One way to fix this is to extend the edge values out by one in the original image while keeping our new image the same size.\nResults # JS CODE IMAGE KERNEL CODE A = 0; B = 0; C = 0; D = 0; E = 1; F = 0; G = 0; H = 0; I = 0; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; function preload() { img = loadImage(\u0026#34;/showcase/sketches/mandrill.png\u0026#34;); } function setup() { createCanvas(512, 512); button = createButton(\u0026#34;Black and White\u0026#34;); button.position(540, 150 + 400); button.mousePressed(blackandwhite); button = createButton(\u0026#34;Blur\u0026#34;); button.position(540, 330 + 400); button.mousePressed(blur); button = createButton(\u0026#34;Identity\u0026#34;); button.position(540, 360 + 400); button.mousePressed(identity); button = createButton(\u0026#34;Outline\u0026#34;); button.position(540, 390 + 400); button.mousePressed(outline); button = createButton(\u0026#34;Right Sobel\u0026#34;); button.position(540, 420 + 400); button.mousePressed(ritsobel); button = createButton(\u0026#34;Emboss\u0026#34;); button.position(540, 450 + 400); button.mousePressed(emboss); button = createButton(\u0026#34;Bottom Sobel\u0026#34;); button.position(540, 480 + 400); button.mousePressed(botsob); noLoop(); } function botsob() { clear(); A = -1; B = -2; C = -1; D = 0; E = 0; F = 0; G = 1; H = 2; I = 1; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; redraw(); } function blackandwhite() { clear(); A = 0; B = 0; C = 0; D = 0; E = 1; F = 0; G = 0; H = 0; I = 0; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; redraw(); } function outline() { clear(); A = -5; B = 4; C = 0; D = 0; E = 2; F = 0; G = 0; H = -1; I = 0; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; redraw(); } function identity() { clear(); A = 0; B = 0; C = 0; D = 0; E = 1; F = 0; G = 0; H = 0; I = 0; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; redraw(); } function blur() { clear(); A = 0.0625; B = 0.125; C = 0.0625; D = 0.125; E = 0.25; F = 0.125; G = 0.0625; H = 0.125; I = 0.0625; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; redraw(); } function ritsobel() { clear(); A = -32; B = 50; C = 45; D = -81; E = 63; F = 68; G = -68; H = 59; I = 59; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; redraw(); } function emboss() { clear(); A = -1.8; B = -1; C = 0; D = -1; E = 1.5; F = 1.5; G = 0.1; H = 1.5; I = 2.5; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; redraw(); } function draw() { image(img, 0, 0); edgeImg = createImage(img.width, img.height); edgeImg.loadPixels(); for (let x = 1; x \u0026lt; img.width - 1; x++) { for (let y = 1; y \u0026lt; img.height - 1; y++) { let sum = 0; for (kx = -1; kx \u0026lt;= 1; kx++) { for (ky = -1; ky \u0026lt;= 1; ky++) { let xpos = x + kx; let ypos = y + ky; let pos = (y + ky) * img.width + (x + kx); let val = red(img.get(xpos, ypos)); sum += kernel[ky + 1][kx + 1] * val; } } edgeImg.set(x, y, color(sum, sum, sum)); } } edgeImg.updatePixels(); image(edgeImg, 0, 0); let colors = extractColors(edgeImg); createImageHistogram(colors[0], colors[1], colors[2]); } function extractColors(image) { let red = []; let green = []; let blue = []; let pixelsNumber = image.width * image.height * 4; for(let i = 0; i \u0026lt; pixelsNumber; i += 4) { red.push(image.pixels[i]); green.push(image.pixels[i + 1]); if (image.pixels[i + 2] != 0) blue.push(image.pixels[i + 2]); } return [red, green, blue]; } function createImageHistogram(red, green, blue) { let red_color = { x: red, name: \u0026#39;red\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;red\u0026#34; }, }; let green_color = { x: green, name: \u0026#39;green\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;green\u0026#34; }, }; let blue_color = { x: blue, name: \u0026#39;blue\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;blue\u0026#34; }, }; let data = [red_color, green_color, blue_color]; let layout = {barmode: \u0026#34;overlay\u0026#34;, }; Plotly.newPlot(\u0026#39;histogram\u0026#39;, data, layout, {displayModeBar: false}); } Apply image kernel\n"},{"id":8,"href":"/showcase/docs/workshop_1/terrain_visualization/","title":"Terrain Visualization","section":"Workshop 1","content":" Terrain Visualization # "}]