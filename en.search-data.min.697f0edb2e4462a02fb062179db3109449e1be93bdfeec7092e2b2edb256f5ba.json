[{"id":0,"href":"/showcase/docs/workshop_1/","title":"Workshop 1","section":"Docs","content":" Workshop 1 # Workshop # Illusions # Study, implement and discuss possible applications of some known visual phenomena and optical illusions. Masking # Implement an image processing web app supporting different image kernels and supporting:\nImage histogram visualization. Different lightness (coloring brightness) tools. Exercises # Coloring # Let rgb1 and rgb2 be two rgb colors. What rgb1 * rgb2 would mean? Spatial coherence # Research spatial coherence visual applications. Terrain visualization # Develop a terrain visualization application. "},{"id":1,"href":"/showcase/docs/workshop_1/illusions/","title":"Illusions","section":"Workshop 1","content":" Visual illusions # Introduction to main illusions used throughout the ebook template which may be classified into two groups: visual artifacts that should be avoided, such as mach bands; and, visual algorithms and applications that may strategically adopted them, such as spatial coherence.\nIllusions workshop # Study, implement and discuss possible applications of some known visual phenomena and optical illusions. From https://visualcomputing.github.io/docs/illusions/\n"},{"id":2,"href":"/showcase/docs/workshop_1/illusions/coloring/","title":"Coloring","section":"Illusions","content":" Illusions - Color Mixing # Explicación # El color es la impresión producida por un tono de luz en los órganos visuales, se trata de un fenómeno físico-químico donde cada color depende de la longitud de onda. En la siguiente animación podemos ver la mezcla aditiva de colores, en la parte izquierda, y la mezcla substractiva de colores en la parte derecha.\nIntuitivamente podemos realizar la mezcla de los colores mediante la cantidad de luz perteneciente al espectro R(red), G(green), B(blue), produciendo todas las posible gamas y tonos, pero adicionalmente podemos sustraer colores aplicando un filtro, que se gradua mediante transparencia y que puede ser de color cyan que permite solo el paso de la luz verde y azul, el filtro magenta permite solo el paso de la luz roja y azul, y por último el filtro amarillo, que permite el paso de la luz roja y verde únicamente.\nCODE function setup() { createCanvas(640, 340); redVal = 0; redUp = true; blueVal = 0; blueUp = true; greenVal = 0; greenUp = true; cyanVal = 0; cyanUp = true; magentaVal = 0; magentaUp = true yellowVal = 0; yellowUp = true; } function draw() { background(220); noStroke(); if(redUp){ redVal = redVal + 1; fill(redVal, 0,0) redUp = redVal \u0026gt; 255 ? false : true; }else{ redVal = redVal - 1; fill(redVal, 0,0) redUp = redVal \u0026lt; 0 ? true : false; } circle(140,100,160) if(greenUp){ greenVal = greenVal +1.5; fill(0, greenVal,0) greenUp = greenVal \u0026gt; 255 ? false : true; }else{ greenVal = greenVal - 1.5; fill(0,greenVal,0) greenUp = greenVal \u0026lt; 0 ? true : false; } circle(170,160,160) if(blueUp){ blueVal = blueVal+2; fill(0, 0, blueVal) blueUp = blueVal \u0026gt; 255 ? false : true; }else{ blueVal = blueVal-2; fill(0,0, blueVal) blueUp = blueVal \u0026lt; 0 ? true : false; } circle(100,160, 160); fill(redVal, 0,blueVal); arc(140,100, 160, 160, 2.07,3.33); arc(100,160, 160, 160, 4.2, 5.39); fill(redVal, greenVal,0); arc(140,100, 160, 160, 6.25, 1.07); arc(170,160, 160, 160, 4.2, 5.39); fill( 0, greenVal, blueVal); arc(170,160, 160, 160, 2.02, PI); arc(100,160, 160, 160, 0, 1.12); fill( redVal, greenVal, blueVal); arc(170,160, 160, 160, 3.11, 4.25); arc(140,100, 160, 160, 1.07, 2.24); arc(100,160, 160, 160, 5.16, 0.125); beginShape(); vertex(260, 120); vertex(290, 120); vertex(290, 150); vertex(260, 150); endShape(CLOSE); beginShape(); vertex(290, 160); vertex(320, 130); vertex(290, 110); endShape(CLOSE); if(cyanUp){ cyanVal = cyanVal+0.5; cyanUp = cyanVal \u0026gt; 255 ? false : true; }else{ cyanVal = cyanVal-0.5; cyanUp = cyanVal \u0026lt; 0 ? true : false; } stroke(0,0,0) fill(0,255,255, cyanVal); beginShape(); vertex(340, 100); vertex(350, 100); vertex(350, 180); vertex(340, 180); endShape(CLOSE); if(magentaUp){ magentaVal = magentaVal+2; magentaUp = magentaVal \u0026gt; 255 ? false : true; }else{ magentaVal = magentaVal-2; magentaUp = magentaVal \u0026lt; 0 ? true : false; } fill(255,0,255, magentaVal); beginShape(); vertex(380, 100); vertex(390, 100); vertex(390, 180); vertex(380, 180); endShape(CLOSE); if(yellowUp){ yellowVal = yellowVal+1; yellowUp = yellowVal \u0026gt; 255 ? false : true; }else{ yellowVal = yellowVal-1; yellowUp = yellowVal \u0026lt; 0 ? true : false; } fill(255,255,0, yellowVal); beginShape(); vertex(420, 100); vertex(430, 100); vertex(430, 180); vertex(420, 180); endShape(CLOSE); fill( redVal-cyanVal, greenVal-magentaVal, blueVal-yellowVal); circle(520,150,120); } "},{"id":3,"href":"/showcase/docs/workshop_1/illusions/lilac_chaser/","title":"Lilac Chaser","section":"Illusions","content":" Illusions - Lilac chaser # Consiste en unos discos de color borrosos alrededor de un punto central, donde en cada frame uno de estos discos desaparece y aparece luego el siguiente hace lo mismo en sentido de las agujas del reloj.\nCODE const CANVAS_SIZE = 500; const DISTANCE = 200; function setup() { createCanvas(CANVAS_SIZE, CANVAS_SIZE); frameRate(10); colorPicker = createColorPicker(\u0026#34;#ee00ee\u0026#34;); colorPicker.position(10, height - 25); circleCountSlider = createSlider(12, 20, 12); circleCountSlider.position(width - 100, height - 20); circleCountSlider.style(\u0026#34;width\u0026#34;, \u0026#34;100px\u0026#34;); blurToggle = createButton(\u0026#34;Blur\u0026#34;); blurToggle.position(width - 30, 10); blurToggle.mousePressed(() =\u0026gt; (blur = !blur)); } function draw() { const CIRCLE_COUNT = circleCountSlider.value(); const CIRCLE_RADIUS = DISTANCE / (CIRCLE_COUNT / 3); if (blur) drawingContext.filter = \u0026#34;blur(20px)\u0026#34;; background(150); noStroke(); fill(colorPicker.color()); for (let i = 0; i \u0026lt; CIRCLE_COUNT; i++) { if (i === frameCount % CIRCLE_COUNT) continue; // skip one circle const angle = (i / CIRCLE_COUNT) * TWO_PI; const x = CANVAS_SIZE / 2 + DISTANCE * cos(angle); const y = CANVAS_SIZE / 2 + DISTANCE * sin(angle); circle(x, y, CIRCLE_RADIUS); } drawingContext.filter = \u0026#34;none\u0026#34;; // cross cursor in the middle stroke(0); translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2); line(-10, 0, 10, 0); line(0, -10, 0, 10); } Explicación # En esta ilusión se pueden observar 3 cosas:\nLa sucesión de la desaparición de los discos aparenta crear un movimiento. Esto es debido a que el ojo humano es capaz de interpretar una sucesión de imágenes y reconocerlas como un movimiento fluido llenando los huecos entre estas.\nEl disco que desaparece toma un color. Esto se debe al efecto de la persistencia de la visión, que es la capacidad del ojo humano de mantener una imagen en la retina durante un tiempo, en este caso la imagen esta en alto contraste con el fondo, por lo que el ojo genera una imagen remanente negativa con el color complementario a los discos.\nLos demás discos comienzan a desaparecer. El desvanecimiento de los discos se debe a que al estar enfocados en un punto por mucho tiempo el cerebro comienza a ignorar aquella información que no sea necesaria, en este caso los discos están borrosos y fuera del punto de enfoque, por lo que el cerebro los ignora.\nAl usar el metodo filter() de p5 para aplicar el efecto de desenfoque en cada uno de los frames, se puede notar que el frameRate baja considerablemente, por este motivo se optó por usar el drawingContext para aplicar el filtro, este provee un filtro que usa directamente el canvas de html5 y por ende no afecta el frameRate tanto. "},{"id":4,"href":"/showcase/docs/workshop_1/illusions/moire/","title":"Moire","section":"Illusions","content":" Illusions - Moiré # Explicación # Patrones de interferencia que pueden producirse cuando se superpone un patrón reglado opaco con huecos transparentes sobre otro patrón similar. CODE let xspeed = 2.3; let yspeed = 2.8; let xdirection = 1; let ydirection = 1; function setup() { createCanvas(700, 700); x1 = width/2; y1 = height/2; n = width/10; d = 50; x2 = width/2; y2 = height/2; } function moire(x,y,d,n){ for( i = 0;i\u0026lt;n;i++){ circle(x, y, d*i); strokeWeight(10); noFill(); } } function txt(){ textFont(\u0026#39;Georgia\u0026#39;); textSize(150); var w = textWidth(\u0026#34;MOIRÉ\u0026#34;); fill(0); fill(255); text(\u0026#34;MOIRÉ\u0026#34;, width/7.5, height/1.75); } function draw() { background(color(\u0026#34;rgb(235,0,0)\u0026#34;)); x2 = x2 + xspeed * xdirection; y2 = y2 + yspeed * ydirection; txt() if (x2 \u0026gt; width || x2 \u0026lt; 0) { xdirection *= -1; } if (y2 \u0026gt; height || y2 \u0026lt; 0) { ydirection *= -1; } m1 = moire(x1,y1,d,n); m2 = moire(x2,y2,d,n); } "},{"id":5,"href":"/showcase/docs/workshop_1/illusions/stepping/","title":"Stepping","section":"Illusions","content":" Illusions - Stepping # Explicación # Las diferencias de contraste entre el amarillo y el blanco y el negro y el azul permiten que se genere la ilusión optica en la que los bloques van dando pasos. Este efecto se ve reforzado cuando el experimento se hace a blanco y negro.\nOprima el mouse para quitar el fondo.\nOprima una tecla para pasar a blanco y negro. CODE function setup() { createCanvas(800, 400); frameRate(45) posX=0 colorA=color(255,255,0) colorB=color(25,25,112) bars=true blackWhite=false } function draw() { background(255); if(bars){ for (i =0;i\u0026lt;800;i=i+40){ fill(color(0)) rect(i, 0, 20, 400); } } noStroke() fill(colorA) rect(posX,140,120,40) fill(colorB) rect(posX,260,120,40) posX=posX+1 if(posX==680){ posX=0 } } function mousePressed() { if(bars==true){ bars=false }else{ bars=true } } function keyPressed(){ if(blackWhite==false){ colorA=color(255) colorB=color(0) blackWhite=true }else{ colorA=color(255,255,0) colorB=color(25,25,112) blackWhite=false } } "},{"id":6,"href":"/showcase/docs/workshop_1/masking/","title":"Masking","section":"Workshop 1","content":" Workshop - Masking # Kernel # In image processing, a kernel, convolution matrix, or mask is a small matrix used for blurring, sharpening, embossing, edge detection, and more. This is accomplished by doing a convolution between the kernel and an image.\nConvolution # Convolution is the process of adding each element of the image to its local neighbors, weighted by the kernel. This is related to a form of mathematical convolution. The matrix operation being performed—convolution—is not traditional matrix multiplication, despite being similarly denoted by *.\nFor each 3x3 block of pixels in the original image , we multiply each pixel by the corresponding entry of the kernel and then take the sum. That sum becomes a new pixel in the result image.\nOne subtlety of this process is what to do along the edges of the image. For example, the top left corner of the input image only has three neighbors. One way to fix this is to extend the edge values out by one in the original image while keeping our new image the same size.\nKERNELS # BOX BLUR:\n\\( \\frac{1}{9} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} \\) EDGE KERNEL:\n\\( \\begin{bmatrix} -5 \u0026amp; 4 \u0026amp; 0\\\\ 0 \u0026amp; 2 \u0026amp; 0\\\\ 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\) OUTLINE KERNEL:\n\\( \\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1\\\\ -1 \u0026amp; 8 \u0026amp; -1\\\\ -1 \u0026amp; -1 \u0026amp; -1 \\end{bmatrix} \\) EMBOSS KERNEL:\n\\( \\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 1 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 2 \\end{bmatrix} \\) BOT SOBEL KERNEL:\n\\( \\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ 1 \u0026amp; 2 \u0026amp; 1 \\end{bmatrix} \\) TOP SOBEL KERNEL:\n\\( \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ -1 \u0026amp; -2 \u0026amp; -1 \\end{bmatrix} \\) Results # JS CODE IMAGE KERNEL CODE A = 0; B = 0; C = 0; D = 0; E = 1; F = 0; G = 0; H = 0; I = 0; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; function preload() { img = loadImage(\u0026#34;/showcase/sketches/mandrill.png\u0026#34;); } function setup() { createCanvas(700, 600); } let boxBlur = [ [1 / 9, 1 / 9, 1 / 9], [1 / 9, 1 / 9, 1 / 9], [1 / 9, 1 / 9, 1 / 9], ]; let edgeKernel = [ [-1, -1, -1], [-1, 8, -1], [-1, -1, -1], ]; let sobelKernel = [ [1, 2, 1], [0, 0, 0], [-1, -2, -1], ]; let outlineKernel = [ [-5, 4, 0], [0, 2, 0], [0, -1, 0], ]; let embossKernel = [ [-2, -1, 0], [-1, 1, 1], [0, 1, 2], ]; let botSobelKernel = [ [-1, -2, -1], [0, 0, 0], [1, 2, 1], ]; let topSobelKernel = [ [1, 2, 1], [0, 0, 0], [-1, -2, -1], ]; function draw(kernelType, size) { image(img, 0, 0); edgeImg = createImage(img.width, img.height); edgeImg.loadPixels(); for (let x = 1; x \u0026lt; img.width - 1; x++) { for (let y = 1; y \u0026lt; img.height - 1; y++) { let sum = 0; for (kx = -1; kx \u0026lt;= 1; kx++) { for (ky = -1; ky \u0026lt;= 1; ky++) { let xpos = x + kx; let ypos = y + ky; let pos = (y + ky) * img.width + (x + kx); let val = red(img.get(xpos, ypos)); sum += kernel[ky + 1][kx + 1] * val; } } edgeImg.set(x, y, color(sum, sum, sum)); } } edgeImg.updatePixels(); image(edgeImg, 0, 0); let colors = extractColors(edgeImg); createImageHistogram(colors[0], colors[1], colors[2]); } function extractColors(image) { let red = []; let green = []; let blue = []; let pixelsNumber = image.width * image.height * 4; for(let i = 0; i \u0026lt; pixelsNumber; i += 4) { red.push(image.pixels[i]); green.push(image.pixels[i + 1]); if (image.pixels[i + 2] != 0) blue.push(image.pixels[i + 2]); } return [red, green, blue]; } function createImageHistogram(red, green, blue) { let red_color = { x: red, name: \u0026#39;red\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;red\u0026#34; }, }; let green_color = { x: green, name: \u0026#39;green\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;green\u0026#34; }, }; let blue_color = { x: blue, name: \u0026#39;blue\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;blue\u0026#34; }, }; let data = [red_color, green_color, blue_color]; let layout = {barmode: \u0026#34;overlay\u0026#34;, }; Plotly.newPlot(\u0026#39;histogram\u0026#39;, data, layout, {displayModeBar: false}); } function changeBrigness(changeFlag) { img.loadPixels(); for (let x = 0; x \u0026lt; img.width; x++) { for (let y = 0; y \u0026lt; img.height; y++) { let loc = (x + y * img.width) * 4; if (changeFlag) { img.pixels[loc] = constrain(img.pixels[loc] / 1.1, 0, 255); img.pixels[loc + 1] = constrain(img.pixels[loc + 1] / 1.1, 0, 255); img.pixels[loc + 2] = constrain(img.pixels[loc + 2] / 1.1, 0, 255); } else { img.pixels[loc] = constrain(img.pixels[loc] * 1.1, 0, 255); img.pixels[loc + 1] = constrain(img.pixels[loc + 1] * 1.1, 0, 255); img.pixels[loc + 2] = constrain(img.pixels[loc + 2] * 1.1, 0, 255); } } } img.updatePixels(); let colors = extractColors(img); createImageHistogram(colors[0], colors[1], colors[2]); } function resetImage() { img.copy(file, 0, 0, file.width, file.height, 0, 0, file.width, file.height); let colors = extractColors(img); createImageHistogram(colors[0], colors[1], colors[2]); } function keyPressed() { switch (key) { case \u0026#34;1\u0026#34;: draw(boxBlur, 3); break; case \u0026#34;2\u0026#34;: draw(edgeKernel, 3); break; case \u0026#34;3\u0026#34;: draw(outlineKernel, 3); break; case \u0026#34;4\u0026#34;: draw(embossKernel, 3); break; case \u0026#34;5\u0026#34;: draw(botSobelKernel, 3); break; case \u0026#34;6\u0026#34;: draw(topSobelKernel, 3); break; case \u0026#34;r\u0026#34;: resetImage(); break; case \u0026#34;+\u0026#34;: changeBrigness(true); break; case \u0026#34;-\u0026#34;: changeBrigness(false); break; } } GENERATE HISTOGRAM IMAGE KERNEL CODE function extractColors(image) { let red = []; let green = []; let blue = []; let pixelsNumber = image.width * image.height * 4; for(let i = 0; i \u0026lt; pixelsNumber; i += 4) { red.push(image.pixels[i]); green.push(image.pixels[i + 1]); if (image.pixels[i + 2] != 0) blue.push(image.pixels[i + 2]); } return [red, green, blue]; } function createImageHistogram(red, green, blue) { let red_color = { x: red, name: \u0026#39;red\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;red\u0026#34; }, }; let green_color = { x: green, name: \u0026#39;green\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;green\u0026#34; }, }; let blue_color = { x: blue, name: \u0026#39;blue\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;blue\u0026#34; }, }; let data = [red_color, green_color, blue_color]; let layout = {barmode: \u0026#34;overlay\u0026#34;, }; Plotly.newPlot(\u0026#39;histogram\u0026#39;, data, layout, {displayModeBar: false}); } CHANGE BRIGHTNESS IMAGE KERNEL CODE function changeBrigness(changeFlag) { img.loadPixels(); for (let x = 0; x \u0026lt; img.width; x++) { for (let y = 0; y \u0026lt; img.height; y++) { let loc = (x + y * img.width) * 4; if (changeFlag) { img.pixels[loc] = constrain(img.pixels[loc] / 1.1, 0, 255); img.pixels[loc + 1] = constrain(img.pixels[loc + 1] / 1.1, 0, 255); img.pixels[loc + 2] = constrain(img.pixels[loc + 2] / 1.1, 0, 255); } else { img.pixels[loc] = constrain(img.pixels[loc] * 1.1, 0, 255); img.pixels[loc + 1] = constrain(img.pixels[loc + 1] * 1.1, 0, 255); img.pixels[loc + 2] = constrain(img.pixels[loc + 2] * 1.1, 0, 255); } } } img.updatePixels(); let colors = extractColors(img); createImageHistogram(colors[0], colors[1], colors[2]); } APLLY KERNEL IMAGES\nShortcuts Shortcut Description 1 Blox Bur 2 Edge Kernel 3 Outline Kernel 4 Emboss Kernel 5 Bot Sobel Kernel 6 Top Sobel Kernel R Reset Image + + Brightness - - Brightness "},{"id":7,"href":"/showcase/docs/workshop_1/terrain_visualization/","title":"Terrain Visualization","section":"Workshop 1","content":" Terrain Visualization # "},{"id":8,"href":"/showcase/docs/workshop_2/","title":"Workshop 2","section":"Docs","content":" Exercises # Rasterization # Implement in software any of the above visualizations: primitive rasterization, color shading, z-depth, texture-mapping (as illustrated above) and/or anti-aliasing (requires a bit of research). "},{"id":9,"href":"/showcase/docs/workshop_2/Bresenhams-line-algorithm-rasterization/","title":"Bresenham'S Line Algorithm (Rasterization)","section":"Workshop 2","content":" Bresenham\u0026rsquo;s line algorithm (rasterization) # Bresenham\u0026rsquo;s line algorithm is a line drawing algorithm that determines the points of an n-dimensional raster that should be selected in order to form a close approximation to a straight line between two points. It is commonly used to draw line primitives in a bitmap image (e.g. on a computer screen), as it uses only integer addition, subtraction and bit shifting, all of which are very cheap operations in commonly used computer instruction sets such as x86_64. It is an incremental error algorithm. It is one of the earliest algorithms developed in the field of computer graphics. An extension to the original algorithm may be used for drawing circles.\nWhile algorithms such as Wu\u0026rsquo;s algorithm are also frequently used in modern computer graphics because they can support antialiasing, the speed and simplicity of Bresenham\u0026rsquo;s line algorithm means that it is still important. The algorithm is used in hardware such as plotters and in the graphics chips of modern graphics cards. It can also be found in many software graphics libraries. Because the algorithm is very simple, it is often implemented in either the firmware or the graphics hardware of modern graphics cards.\nThe label \u0026ldquo;Bresenham\u0026rdquo; is used today for a family of algorithms extending or modifying Bresenham\u0026rsquo;s original algorithm.\n"}]