[{"id":0,"href":"/showcase/docs/workshop_1/","title":"Workshop 1","section":"Docs","content":" Workshop 1 # Workshop # Illusions # Study, implement and discuss possible applications of some known visual phenomena and optical illusions. Masking # Implement an image processing web app supporting different image kernels and supporting:\nImage histogram visualization. Different lightness (coloring brightness) tools. Exercises # Coloring # Let rgb1 and rgb2 be two rgb colors. What rgb1 * rgb2 would mean? Spatial coherence # Research spatial coherence visual applications. Terrain visualization # Develop a terrain visualization application. "},{"id":1,"href":"/showcase/docs/workshop_1/illusions/","title":"Illusions","section":"Workshop 1","content":" Visual illusions # Introduction to main illusions used throughout the ebook template which may be classified into two groups: visual artifacts that should be avoided, such as mach bands; and, visual algorithms and applications that may strategically adopted them, such as spatial coherence.\nIllusions workshop # Study, implement and discuss possible applications of some known visual phenomena and optical illusions. From https://visualcomputing.github.io/docs/illusions/\n"},{"id":2,"href":"/showcase/docs/workshop_1/illusions/coloring/","title":"Coloring","section":"Illusions","content":" Illusions - Color Mixing # Explicación # El color es la impresión producida por un tono de luz en los órganos visuales, se trata de un fenómeno físico-químico donde cada color depende de la longitud de onda. En la siguiente animación podemos ver la mezcla aditiva de colores, en la parte izquierda, y la mezcla substractiva de colores en la parte derecha.\nIntuitivamente podemos realizar la mezcla de los colores mediante la cantidad de luz perteneciente al espectro R(red), G(green), B(blue), produciendo todas las posible gamas y tonos, pero adicionalmente podemos sustraer colores aplicando un filtro, que se gradua mediante transparencia y que puede ser de color cyan que permite solo el paso de la luz verde y azul, el filtro magenta permite solo el paso de la luz roja y azul, y por último el filtro amarillo, que permite el paso de la luz roja y verde únicamente.\nCODE function setup() { createCanvas(640, 340); redVal = 0; redUp = true; blueVal = 0; blueUp = true; greenVal = 0; greenUp = true; cyanVal = 0; cyanUp = true; magentaVal = 0; magentaUp = true yellowVal = 0; yellowUp = true; } function draw() { background(220); noStroke(); if(redUp){ redVal = redVal + 1; fill(redVal, 0,0) redUp = redVal \u0026gt; 255 ? false : true; }else{ redVal = redVal - 1; fill(redVal, 0,0) redUp = redVal \u0026lt; 0 ? true : false; } circle(140,100,160) if(greenUp){ greenVal = greenVal +1.5; fill(0, greenVal,0) greenUp = greenVal \u0026gt; 255 ? false : true; }else{ greenVal = greenVal - 1.5; fill(0,greenVal,0) greenUp = greenVal \u0026lt; 0 ? true : false; } circle(170,160,160) if(blueUp){ blueVal = blueVal+2; fill(0, 0, blueVal) blueUp = blueVal \u0026gt; 255 ? false : true; }else{ blueVal = blueVal-2; fill(0,0, blueVal) blueUp = blueVal \u0026lt; 0 ? true : false; } circle(100,160, 160); fill(redVal, 0,blueVal); arc(140,100, 160, 160, 2.07,3.33); arc(100,160, 160, 160, 4.2, 5.39); fill(redVal, greenVal,0); arc(140,100, 160, 160, 6.25, 1.07); arc(170,160, 160, 160, 4.2, 5.39); fill( 0, greenVal, blueVal); arc(170,160, 160, 160, 2.02, PI); arc(100,160, 160, 160, 0, 1.12); fill( redVal, greenVal, blueVal); arc(170,160, 160, 160, 3.11, 4.25); arc(140,100, 160, 160, 1.07, 2.24); arc(100,160, 160, 160, 5.16, 0.125); beginShape(); vertex(260, 120); vertex(290, 120); vertex(290, 150); vertex(260, 150); endShape(CLOSE); beginShape(); vertex(290, 160); vertex(320, 130); vertex(290, 110); endShape(CLOSE); if(cyanUp){ cyanVal = cyanVal+0.5; cyanUp = cyanVal \u0026gt; 255 ? false : true; }else{ cyanVal = cyanVal-0.5; cyanUp = cyanVal \u0026lt; 0 ? true : false; } stroke(0,0,0) fill(0,255,255, cyanVal); beginShape(); vertex(340, 100); vertex(350, 100); vertex(350, 180); vertex(340, 180); endShape(CLOSE); if(magentaUp){ magentaVal = magentaVal+2; magentaUp = magentaVal \u0026gt; 255 ? false : true; }else{ magentaVal = magentaVal-2; magentaUp = magentaVal \u0026lt; 0 ? true : false; } fill(255,0,255, magentaVal); beginShape(); vertex(380, 100); vertex(390, 100); vertex(390, 180); vertex(380, 180); endShape(CLOSE); if(yellowUp){ yellowVal = yellowVal+1; yellowUp = yellowVal \u0026gt; 255 ? false : true; }else{ yellowVal = yellowVal-1; yellowUp = yellowVal \u0026lt; 0 ? true : false; } fill(255,255,0, yellowVal); beginShape(); vertex(420, 100); vertex(430, 100); vertex(430, 180); vertex(420, 180); endShape(CLOSE); fill( redVal-cyanVal, greenVal-magentaVal, blueVal-yellowVal); circle(520,150,120); } "},{"id":3,"href":"/showcase/docs/workshop_1/illusions/lilac_chaser/","title":"Lilac Chaser","section":"Illusions","content":" Illusions - Lilac chaser # Consiste en unos discos de color borrosos alrededor de un punto central, donde en cada frame uno de estos discos desaparece y aparece luego el siguiente hace lo mismo en sentido de las agujas del reloj.\nCODE const CANVAS_SIZE = 500; const DISTANCE = 200; function setup() { createCanvas(CANVAS_SIZE, CANVAS_SIZE); frameRate(10); colorPicker = createColorPicker(\u0026#34;#ee00ee\u0026#34;); colorPicker.position(10, height - 25); circleCountSlider = createSlider(12, 20, 12); circleCountSlider.position(width - 100, height - 20); circleCountSlider.style(\u0026#34;width\u0026#34;, \u0026#34;100px\u0026#34;); blurToggle = createButton(\u0026#34;Blur\u0026#34;); blurToggle.position(width - 30, 10); blurToggle.mousePressed(() =\u0026gt; (blur = !blur)); } function draw() { const CIRCLE_COUNT = circleCountSlider.value(); const CIRCLE_RADIUS = DISTANCE / (CIRCLE_COUNT / 3); if (blur) drawingContext.filter = \u0026#34;blur(20px)\u0026#34;; background(150); noStroke(); fill(colorPicker.color()); for (let i = 0; i \u0026lt; CIRCLE_COUNT; i++) { if (i === frameCount % CIRCLE_COUNT) continue; // skip one circle const angle = (i / CIRCLE_COUNT) * TWO_PI; const x = CANVAS_SIZE / 2 + DISTANCE * cos(angle); const y = CANVAS_SIZE / 2 + DISTANCE * sin(angle); circle(x, y, CIRCLE_RADIUS); } drawingContext.filter = \u0026#34;none\u0026#34;; // cross cursor in the middle stroke(0); translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2); line(-10, 0, 10, 0); line(0, -10, 0, 10); } Explicación # En esta ilusión se pueden observar 3 cosas:\nLa sucesión de la desaparición de los discos aparenta crear un movimiento. Esto es debido a que el ojo humano es capaz de interpretar una sucesión de imágenes y reconocerlas como un movimiento fluido llenando los huecos entre estas.\nEl disco que desaparece toma un color. Esto se debe al efecto de la persistencia de la visión, que es la capacidad del ojo humano de mantener una imagen en la retina durante un tiempo, en este caso la imagen esta en alto contraste con el fondo, por lo que el ojo genera una imagen remanente negativa con el color complementario a los discos.\nLos demás discos comienzan a desaparecer. El desvanecimiento de los discos se debe a que al estar enfocados en un punto por mucho tiempo el cerebro comienza a ignorar aquella información que no sea necesaria, en este caso los discos están borrosos y fuera del punto de enfoque, por lo que el cerebro los ignora.\nAl usar el metodo filter() de p5 para aplicar el efecto de desenfoque en cada uno de los frames, se puede notar que el frameRate baja considerablemente, por este motivo se optó por usar el drawingContext para aplicar el filtro, este provee un filtro que usa directamente el canvas de html5 y por ende no afecta el frameRate tanto. "},{"id":4,"href":"/showcase/docs/workshop_1/illusions/moire/","title":"Moire","section":"Illusions","content":" Illusions - Moiré # Explicación # Patrones de interferencia que pueden producirse cuando se superpone un patrón reglado opaco con huecos transparentes sobre otro patrón similar. CODE let xspeed = 2.3; let yspeed = 2.8; let xdirection = 1; let ydirection = 1; function setup() { createCanvas(700, 700); x1 = width/2; y1 = height/2; n = width/10; d = 50; x2 = width/2; y2 = height/2; } function moire(x,y,d,n){ for( i = 0;i\u0026lt;n;i++){ circle(x, y, d*i); strokeWeight(10); noFill(); } } function txt(){ textFont(\u0026#39;Georgia\u0026#39;); textSize(150); var w = textWidth(\u0026#34;MOIRÉ\u0026#34;); fill(0); fill(255); text(\u0026#34;MOIRÉ\u0026#34;, width/7.5, height/1.75); } function draw() { background(color(\u0026#34;rgb(235,0,0)\u0026#34;)); x2 = x2 + xspeed * xdirection; y2 = y2 + yspeed * ydirection; txt() if (x2 \u0026gt; width || x2 \u0026lt; 0) { xdirection *= -1; } if (y2 \u0026gt; height || y2 \u0026lt; 0) { ydirection *= -1; } m1 = moire(x1,y1,d,n); m2 = moire(x2,y2,d,n); } "},{"id":5,"href":"/showcase/docs/workshop_1/illusions/stepping/","title":"Stepping","section":"Illusions","content":" Illusions - Stepping # Explicación # Las diferencias de contraste entre el amarillo y el blanco y el negro y el azul permiten que se genere la ilusión optica en la que los bloques van dando pasos. Este efecto se ve reforzado cuando el experimento se hace a blanco y negro.\nOprima el mouse para quitar el fondo.\nOprima una tecla para pasar a blanco y negro. CODE function setup() { createCanvas(800, 400); frameRate(45) posX=0 colorA=color(255,255,0) colorB=color(25,25,112) bars=true blackWhite=false } function draw() { background(255); if(bars){ for (i =0;i\u0026lt;800;i=i+40){ fill(color(0)) rect(i, 0, 20, 400); } } noStroke() fill(colorA) rect(posX,140,120,40) fill(colorB) rect(posX,260,120,40) posX=posX+1 if(posX==680){ posX=0 } } function mousePressed() { if(bars==true){ bars=false }else{ bars=true } } function keyPressed(){ if(blackWhite==false){ colorA=color(255) colorB=color(0) blackWhite=true }else{ colorA=color(255,255,0) colorB=color(25,25,112) blackWhite=false } } "},{"id":6,"href":"/showcase/docs/workshop_1/masking/","title":"Masking","section":"Workshop 1","content":" Workshop - Masking # Kernel # In image processing, a kernel, convolution matrix, or mask is a small matrix used for blurring, sharpening, embossing, edge detection, and more. This is accomplished by doing a convolution between the kernel and an image.\nConvolution # Convolution is the process of adding each element of the image to its local neighbors, weighted by the kernel. This is related to a form of mathematical convolution. The matrix operation being performed—convolution—is not traditional matrix multiplication, despite being similarly denoted by *.\nFor each 3x3 block of pixels in the original image , we multiply each pixel by the corresponding entry of the kernel and then take the sum. That sum becomes a new pixel in the result image.\nOne subtlety of this process is what to do along the edges of the image. For example, the top left corner of the input image only has three neighbors. One way to fix this is to extend the edge values out by one in the original image while keeping our new image the same size.\nKERNELS # BOX BLUR:\n\\( \\frac{1}{9} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} \\) EDGE KERNEL:\n\\( \\begin{bmatrix} -5 \u0026amp; 4 \u0026amp; 0\\\\ 0 \u0026amp; 2 \u0026amp; 0\\\\ 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\) OUTLINE KERNEL:\n\\( \\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1\\\\ -1 \u0026amp; 8 \u0026amp; -1\\\\ -1 \u0026amp; -1 \u0026amp; -1 \\end{bmatrix} \\) EMBOSS KERNEL:\n\\( \\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 1 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 2 \\end{bmatrix} \\) BOT SOBEL KERNEL:\n\\( \\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ 1 \u0026amp; 2 \u0026amp; 1 \\end{bmatrix} \\) TOP SOBEL KERNEL:\n\\( \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 1\\\\ 0 \u0026amp; 0 \u0026amp; 0\\\\ -1 \u0026amp; -2 \u0026amp; -1 \\end{bmatrix} \\) Results # JS CODE IMAGE KERNEL CODE A = 0; B = 0; C = 0; D = 0; E = 1; F = 0; G = 0; H = 0; I = 0; kernel = [ [A, B, C], [D, E, -F], [G, H, I], ]; function preload() { img = loadImage(\u0026#34;/showcase/sketches/mandrill.png\u0026#34;); } function setup() { createCanvas(700, 600); } let boxBlur = [ [1 / 9, 1 / 9, 1 / 9], [1 / 9, 1 / 9, 1 / 9], [1 / 9, 1 / 9, 1 / 9], ]; let edgeKernel = [ [-1, -1, -1], [-1, 8, -1], [-1, -1, -1], ]; let sobelKernel = [ [1, 2, 1], [0, 0, 0], [-1, -2, -1], ]; let outlineKernel = [ [-5, 4, 0], [0, 2, 0], [0, -1, 0], ]; let embossKernel = [ [-2, -1, 0], [-1, 1, 1], [0, 1, 2], ]; let botSobelKernel = [ [-1, -2, -1], [0, 0, 0], [1, 2, 1], ]; let topSobelKernel = [ [1, 2, 1], [0, 0, 0], [-1, -2, -1], ]; function draw(kernelType, size) { image(img, 0, 0); edgeImg = createImage(img.width, img.height); edgeImg.loadPixels(); for (let x = 1; x \u0026lt; img.width - 1; x++) { for (let y = 1; y \u0026lt; img.height - 1; y++) { let sum = 0; for (kx = -1; kx \u0026lt;= 1; kx++) { for (ky = -1; ky \u0026lt;= 1; ky++) { let xpos = x + kx; let ypos = y + ky; let pos = (y + ky) * img.width + (x + kx); let val = red(img.get(xpos, ypos)); sum += kernel[ky + 1][kx + 1] * val; } } edgeImg.set(x, y, color(sum, sum, sum)); } } edgeImg.updatePixels(); image(edgeImg, 0, 0); let colors = extractColors(edgeImg); createImageHistogram(colors[0], colors[1], colors[2]); } function extractColors(image) { let red = []; let green = []; let blue = []; let pixelsNumber = image.width * image.height * 4; for(let i = 0; i \u0026lt; pixelsNumber; i += 4) { red.push(image.pixels[i]); green.push(image.pixels[i + 1]); if (image.pixels[i + 2] != 0) blue.push(image.pixels[i + 2]); } return [red, green, blue]; } function createImageHistogram(red, green, blue) { let red_color = { x: red, name: \u0026#39;red\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;red\u0026#34; }, }; let green_color = { x: green, name: \u0026#39;green\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;green\u0026#34; }, }; let blue_color = { x: blue, name: \u0026#39;blue\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;blue\u0026#34; }, }; let data = [red_color, green_color, blue_color]; let layout = {barmode: \u0026#34;overlay\u0026#34;, }; Plotly.newPlot(\u0026#39;histogram\u0026#39;, data, layout, {displayModeBar: false}); } function changeBrigness(changeFlag) { img.loadPixels(); for (let x = 0; x \u0026lt; img.width; x++) { for (let y = 0; y \u0026lt; img.height; y++) { let loc = (x + y * img.width) * 4; if (changeFlag) { img.pixels[loc] = constrain(img.pixels[loc] / 1.1, 0, 255); img.pixels[loc + 1] = constrain(img.pixels[loc + 1] / 1.1, 0, 255); img.pixels[loc + 2] = constrain(img.pixels[loc + 2] / 1.1, 0, 255); } else { img.pixels[loc] = constrain(img.pixels[loc] * 1.1, 0, 255); img.pixels[loc + 1] = constrain(img.pixels[loc + 1] * 1.1, 0, 255); img.pixels[loc + 2] = constrain(img.pixels[loc + 2] * 1.1, 0, 255); } } } img.updatePixels(); let colors = extractColors(img); createImageHistogram(colors[0], colors[1], colors[2]); } function resetImage() { img.copy(file, 0, 0, file.width, file.height, 0, 0, file.width, file.height); let colors = extractColors(img); createImageHistogram(colors[0], colors[1], colors[2]); } function keyPressed() { switch (key) { case \u0026#34;1\u0026#34;: draw(boxBlur, 3); break; case \u0026#34;2\u0026#34;: draw(edgeKernel, 3); break; case \u0026#34;3\u0026#34;: draw(outlineKernel, 3); break; case \u0026#34;4\u0026#34;: draw(embossKernel, 3); break; case \u0026#34;5\u0026#34;: draw(botSobelKernel, 3); break; case \u0026#34;6\u0026#34;: draw(topSobelKernel, 3); break; case \u0026#34;r\u0026#34;: resetImage(); break; case \u0026#34;+\u0026#34;: changeBrigness(true); break; case \u0026#34;-\u0026#34;: changeBrigness(false); break; } } GENERATE HISTOGRAM IMAGE KERNEL CODE function extractColors(image) { let red = []; let green = []; let blue = []; let pixelsNumber = image.width * image.height * 4; for(let i = 0; i \u0026lt; pixelsNumber; i += 4) { red.push(image.pixels[i]); green.push(image.pixels[i + 1]); if (image.pixels[i + 2] != 0) blue.push(image.pixels[i + 2]); } return [red, green, blue]; } function createImageHistogram(red, green, blue) { let red_color = { x: red, name: \u0026#39;red\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;red\u0026#34; }, }; let green_color = { x: green, name: \u0026#39;green\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;green\u0026#34; }, }; let blue_color = { x: blue, name: \u0026#39;blue\u0026#39;, type: \u0026#34;histogram\u0026#34;, opacity: 0.5, marker: { color: \u0026#34;blue\u0026#34; }, }; let data = [red_color, green_color, blue_color]; let layout = {barmode: \u0026#34;overlay\u0026#34;, }; Plotly.newPlot(\u0026#39;histogram\u0026#39;, data, layout, {displayModeBar: false}); } CHANGE BRIGHTNESS IMAGE KERNEL CODE function changeBrigness(changeFlag) { img.loadPixels(); for (let x = 0; x \u0026lt; img.width; x++) { for (let y = 0; y \u0026lt; img.height; y++) { let loc = (x + y * img.width) * 4; if (changeFlag) { img.pixels[loc] = constrain(img.pixels[loc] / 1.1, 0, 255); img.pixels[loc + 1] = constrain(img.pixels[loc + 1] / 1.1, 0, 255); img.pixels[loc + 2] = constrain(img.pixels[loc + 2] / 1.1, 0, 255); } else { img.pixels[loc] = constrain(img.pixels[loc] * 1.1, 0, 255); img.pixels[loc + 1] = constrain(img.pixels[loc + 1] * 1.1, 0, 255); img.pixels[loc + 2] = constrain(img.pixels[loc + 2] * 1.1, 0, 255); } } } img.updatePixels(); let colors = extractColors(img); createImageHistogram(colors[0], colors[1], colors[2]); } APLLY KERNEL IMAGES\nShortcuts Shortcut Description 1 Blox Bur 2 Edge Kernel 3 Outline Kernel 4 Emboss Kernel 5 Bot Sobel Kernel 6 Top Sobel Kernel R Reset Image + + Brightness - - Brightness "},{"id":7,"href":"/showcase/docs/workshop_1/terrain_visualization/","title":"Terrain Visualization","section":"Workshop 1","content":" Terrain Visualization # "},{"id":8,"href":"/showcase/docs/workshop_2/","title":"Workshop 2","section":"Docs","content":" Workshop 2 # Workshop # Implement a 3d webgl application. The p5.treegl or any other libraries may be used. Last commit deadline: 24h, 17(18)/10/22; presentations: 18(19)/10/22. Exercises # Rasterization # Implement in software any of the above visualizations: primitive rasterization, color shading, z-depth, texture-mapping (as illustrated above) and/or anti-aliasing (requires a bit of research). "},{"id":9,"href":"/showcase/docs/workshop_2/Bresenhams-line-algorithm-rasterization/","title":"Bresenham'S Line Algorithm (Rasterization)","section":"Workshop 2","content":" Bresenham\u0026rsquo;s line algorithm (rasterization) # Bresenham\u0026rsquo;s line algorithm is a line drawing algorithm that determines the points of an n-dimensional raster that should be selected in order to form a close approximation to a straight line between two points. It is commonly used to draw line primitives in a bitmap image (e.g. on a computer screen), as it uses only integer addition, subtraction and bit shifting, all of which are very cheap operations in commonly used computer instruction sets such as x86_64. It is an incremental error algorithm. It is one of the earliest algorithms developed in the field of computer graphics. An extension to the original algorithm may be used for drawing circles.\nWhile algorithms such as Wu\u0026rsquo;s algorithm are also frequently used in modern computer graphics because they can support antialiasing, the speed and simplicity of Bresenham\u0026rsquo;s line algorithm means that it is still important. The algorithm is used in hardware such as plotters and in the graphics chips of modern graphics cards. It can also be found in many software graphics libraries. Because the algorithm is very simple, it is often implemented in either the firmware or the graphics hardware of modern graphics cards.\nThe label \u0026ldquo;Bresenham\u0026rdquo; is used today for a family of algorithms extending or modifying Bresenham\u0026rsquo;s original algorithm.\n"},{"id":10,"href":"/showcase/docs/workshop_2/rubik/","title":"Rubik","section":"Workshop 2","content":" Rubik\u0026rsquo;s cube # Introduction # The Rubik\u0026rsquo;s cube is a 3x3x3 cube with 6 faces. Each face has 9 stickers, each sticker has a color. The cube can be rotated in 3 dimensions. The goal is to rotate the cube so that each face has the same color.\nCODE const WIDTH = 500, HEIGHT = 500; const SIZE = WIDTH / 15; const MOVES = [ \u0026#34;U\u0026#34;, \u0026#34;U\u0026#39;\u0026#34;, \u0026#34;U2\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;D\u0026#39;\u0026#34;, \u0026#34;D2\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;R\u0026#39;\u0026#34;, \u0026#34;R2\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;L\u0026#39;\u0026#34;, \u0026#34;L2\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;F\u0026#39;\u0026#34;, \u0026#34;F2\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;B\u0026#39;\u0026#34;, \u0026#34;B2\u0026#34;, ]; const COLOR_MAP = { 1: [255], 2: [255, 255, 0], 3: [255, 0, 0], 4: [255, 128, 0], 5: [0, 255, 0], 6: [0, 0, 255], }; const KEY_MAP = { U: () =\u0026gt; turnFace(up, 0), \u0026#34;U\u0026#39;\u0026#34;: () =\u0026gt; { turnFace(up, 0); turnFace(up, 0); turnFace(up, 0); }, U2: () =\u0026gt; { turnFace(up, 0); turnFace(up, 0); }, D: () =\u0026gt; turnFace(down, 1), \u0026#34;D\u0026#39;\u0026#34;: () =\u0026gt; { turnFace(down, 1); turnFace(down, 1); turnFace(down, 1); }, D2: () =\u0026gt; { turnFace(down, 1); turnFace(down, 1); }, R: () =\u0026gt; turnFace(right, 2), \u0026#34;R\u0026#39;\u0026#34;: () =\u0026gt; { turnFace(right, 2); turnFace(right, 2); turnFace(right, 2); }, R2: () =\u0026gt; { turnFace(right, 2); turnFace(right, 2); }, L: () =\u0026gt; turnFace(left, 3), \u0026#34;L\u0026#39;\u0026#34;: () =\u0026gt; { turnFace(left, 3); turnFace(left, 3); turnFace(left, 3); }, L2: () =\u0026gt; { turnFace(left, 3); turnFace(left, 3); }, F: () =\u0026gt; turnFace(front, 4), \u0026#34;F\u0026#39;\u0026#34;: () =\u0026gt; { turnFace(front, 4); turnFace(front, 4); turnFace(front, 4); }, F2: () =\u0026gt; { turnFace(front, 4); turnFace(front, 4); }, B: () =\u0026gt; turnFace(back, 5), \u0026#34;B\u0026#39;\u0026#34;: () =\u0026gt; { turnFace(back, 5); turnFace(back, 5); turnFace(back, 5); }, B2: () =\u0026gt; { turnFace(back, 5); turnFace(back, 5); }, }; let up, down, right, left, front, back; let easycam; // eslint-disable-next-line no-unused-vars function setup() { createCanvas(WIDTH, HEIGHT, WEBGL); setAttributes(\u0026#34;antialias\u0026#34;, true); initPos(); easycam = createEasyCam(); easycam.rotateY(PI / 4); easycam.rotateX(PI / 8); easycam.setDistance(250); easycam.setDistanceMin(200); easycam.setDistanceMax(500); createUI(); } // eslint-disable-next-line no-unused-vars function draw() { background(0); strokeWeight(3); translate((-SIZE * 3) / 2, (-SIZE * 3) / 2, (SIZE * 3) / 2); paintFace(up, 0, 0, -SIZE * 3, PI / 2, 0, 0); paintFace(down, 0, SIZE * 3, 0, -PI / 2, 0, 0); paintFace(right, SIZE * 3, 0, 0, 0, PI / 2, 0); paintFace(left, 0, 0, -SIZE * 3, 0, -PI / 2, 0); paintFace(front, 0, 0, 0, 0, 0, 0); paintFace(back, SIZE * 3, 0, -SIZE * 3, 0, PI, 0); } function paintFace(face, x, y, z, rotX, rotY, rotZ) { push(); translate(x, y, z); rotateX(rotX); rotateY(rotY); rotateZ(rotZ); for (let i = 0; i \u0026lt; 3; i++) { for (let j = 0; j \u0026lt; 3; j++) { fill(COLOR_MAP[face[i][j]]); rect(i * SIZE, j * SIZE, SIZE, SIZE); } } pop(); } function scramble() { let moves = []; for (let i = 0; i \u0026lt; 20; i++) { let move = MOVES[floor(random(0, MOVES.length))]; if (KEY_MAP[move]) KEY_MAP[move](); moves.push(move); } print(moves); document.getElementById(\u0026#34;moves\u0026#34;).innerHTML = moves.join(\u0026#34; \u0026#34;); } function initPos() { up = new Array(3).fill(1).map(() =\u0026gt; new Array(3).fill(1)); down = new Array(3).fill(2).map(() =\u0026gt; new Array(3).fill(2)); right = new Array(3).fill(3).map(() =\u0026gt; new Array(3).fill(3)); left = new Array(3).fill(4).map(() =\u0026gt; new Array(3).fill(4)); front = new Array(3).fill(5).map(() =\u0026gt; new Array(3).fill(5)); back = new Array(3).fill(6).map(() =\u0026gt; new Array(3).fill(6)); } function createUI() { createButton(\u0026#34;Scramble\u0026#34;) .mousePressed(scramble) .position(width + 20, 20); createButton(\u0026#34;Reset\u0026#34;) .mousePressed(initPos) .position(width + 20, 60); let button_size = 30; let spacing = 10; createDiv(\u0026#34;🔃\u0026#34;) .position(width + 20, 150) .style(\u0026#34;font-size\u0026#34;, \u0026#34;20px\u0026#34;); createDiv(\u0026#34;🔄️\u0026#34;) .position(width + 20 + button_size + spacing, 150) .style(\u0026#34;font-size\u0026#34;, \u0026#34;20px\u0026#34;); createDiv(\u0026#34;2️⃣\u0026#34;) .position(width + 20 + (button_size + spacing) * 2, 150) .style(\u0026#34;font-size\u0026#34;, \u0026#34;20px\u0026#34;); MOVES.forEach((move, i) =\u0026gt; { let color = [0, 0, 0]; if (move.includes(\u0026#34;U\u0026#34;)) color = COLOR_MAP[1]; if (move.includes(\u0026#34;D\u0026#34;)) color = COLOR_MAP[2]; if (move.includes(\u0026#34;R\u0026#34;)) color = COLOR_MAP[3]; if (move.includes(\u0026#34;L\u0026#34;)) color = COLOR_MAP[4]; if (move.includes(\u0026#34;F\u0026#34;)) color = COLOR_MAP[5]; if (move.includes(\u0026#34;B\u0026#34;)) color = COLOR_MAP[6]; createButton(move) .mousePressed(KEY_MAP[move]) .position( 10 + width + spacing + (i % 3) * (button_size + spacing), 180 + spacing + floor(i / 3) * (button_size + spacing), ) .size(button_size, button_size) .style(\u0026#34;background-color\u0026#34;, `rgb(${color[0]}, ${color[1]}, ${color[2]})`); }); selectAll(\u0026#34;button\u0026#34;).forEach((button) =\u0026gt; { button.style(\u0026#34;font-size\u0026#34;, \u0026#34;12pt\u0026#34;); button.style(\u0026#34;font-weight\u0026#34;, \u0026#34;bold\u0026#34;); button.style(\u0026#34;text-align\u0026#34;, \u0026#34;center\u0026#34;); }); // text for the scramble moves createDiv(\u0026#34;\u0026#34;) // position bottom with white letters .position(20, height - 40) .style(\u0026#34;color\u0026#34;, \u0026#34;white\u0026#34;) .style(\u0026#34;font-size\u0026#34;, \u0026#34;20px\u0026#34;) .id(\u0026#34;moves\u0026#34;); } function turnFace(face, n) { let temp; if (n == 0) { temp = front[0][0]; front[0][0] = right[0][0]; right[0][0] = back[0][0]; back[0][0] = left[0][0]; left[0][0] = temp; temp = front[1][0]; front[1][0] = right[1][0]; right[1][0] = back[1][0]; back[1][0] = left[1][0]; left[1][0] = temp; temp = front[2][0]; front[2][0] = right[2][0]; right[2][0] = back[2][0]; back[2][0] = left[2][0]; left[2][0] = temp; } if (n == 1) { temp = front[0][2]; front[0][2] = left[0][2]; left[0][2] = back[0][2]; back[0][2] = right[0][2]; right[0][2] = temp; temp = front[1][2]; front[1][2] = left[1][2]; left[1][2] = back[1][2]; back[1][2] = right[1][2]; right[1][2] = temp; temp = front[2][2]; front[2][2] = left[2][2]; left[2][2] = back[2][2]; back[2][2] = right[2][2]; right[2][2] = temp; } if (n == 2) { temp = front[2][0]; front[2][0] = down[2][0]; down[2][0] = back[0][2]; back[0][2] = up[2][0]; up[2][0] = temp; temp = front[2][1]; front[2][1] = down[2][1]; down[2][1] = back[0][1]; back[0][1] = up[2][1]; up[2][1] = temp; temp = front[2][2]; front[2][2] = down[2][2]; down[2][2] = back[0][0]; back[0][0] = up[2][2]; up[2][2] = temp; } if (n == 3) { temp = back[2][0]; back[2][0] = down[0][2]; down[0][2] = front[0][2]; front[0][2] = up[0][2]; up[0][2] = temp; temp = back[2][1]; back[2][1] = down[0][1]; down[0][1] = front[0][1]; front[0][1] = up[0][1]; up[0][1] = temp; temp = back[2][2]; back[2][2] = down[0][0]; down[0][0] = front[0][0]; front[0][0] = up[0][0]; up[0][0] = temp; } if (n == 4) { temp = up[0][2]; up[0][2] = left[2][2]; left[2][2] = down[2][0]; down[2][0] = right[0][0]; right[0][0] = temp; temp = up[1][2]; up[1][2] = left[2][1]; left[2][1] = down[1][0]; down[1][0] = right[0][1]; right[0][1] = temp; temp = up[2][2]; up[2][2] = left[2][0]; left[2][0] = down[0][0]; down[0][0] = right[0][2]; right[0][2] = temp; } if (n == 5) { temp = up[0][0]; up[0][0] = right[2][0]; right[2][0] = down[2][2]; down[2][2] = left[0][2]; left[0][2] = temp; temp = up[1][0]; up[1][0] = right[2][1]; right[2][1] = down[1][2]; down[1][2] = left[0][1]; left[0][1] = temp; temp = up[2][0]; up[2][0] = right[2][2]; right[2][2] = down[0][2]; down[0][2] = left[0][0]; left[0][0] = temp; } temp = face[0][0]; face[0][0] = face[0][2]; face[0][2] = face[2][2]; face[2][2] = face[2][0]; face[2][0] = temp; temp = face[0][1]; face[0][1] = face[1][2]; face[1][2] = face[2][1]; face[2][1] = face[1][0]; face[1][0] = temp; } This code makes use of:\nP5\u0026rsquo;s basic translation and rotation for the cube movements.\nThe easyCam library to move the camera around the cube.\nA simple GUI with buttons to control the cube.\n"},{"id":11,"href":"/showcase/docs/workshop_2/skeleton/","title":"Skeleton","section":"Workshop 2","content":" Visualization of an skeleton render # Allows the visualization of a 3d model of a skeleton with its individual parts as separate .obj files.\nPossible applications:\nMedical image analysis Position animation Anatomical atlas Modelo original obtenido de: https://sketchfab.com/3d-models/low-poly-skeleton-4866bd05df2d4febba463295cd24b564\n"},{"id":12,"href":"/showcase/docs/workshop_3/","title":"Workshop 3","section":"Docs","content":" Workshop 3 # Exercises # Figure it out the js code of the above sketches. Implement other blending modes. Take this reference as starting point. Exercise # Redefine the shape texture coordinates to turn the above image upside down. Exercises # Include the blue channel in the uv visualization (e.g., use blue with red or green channels). Use other shapes different than the quad as screen filters. Exercises # Implement other coloring brightness tools such as HSV value V, HSL lightness L or Component average. Implement texture tinting by mixing color and texel interpolated data. Exercise # Implement an image / video processing app supporting different masks, including other kernel sizes different than 3x3, and:\nA region-of-interest base tool to selectively apply a given mask.Hint: circular regions around the mouse pointer are handy and quite simple to implement by means of glsl distance. A magnifier tool. Requires a bit of research. For instance, look for it in shadertoy. Integrate luma and other coloring brightness tools. What other shader tools would you implement?\nExercise # Adapt other patterns from the book of shaders (refer also to the shadertoy collection) and map them as textures onto other 3D shapes. Exercises # Figure out the fragment shader code. Hint: the key to properly sample the texture is to observe that the tepotTex, the near plane and screen space are all isomorphic, i.e., they simply differ by a scaling factor:\nComplete the other cube faces.\nUse other platonic solids.\nWhat other non-euclidean geometries applications would you like to implement?\nExercises # Implement your own source dataset and a mechanism to select different images from it. Implement a pixelator in software that doesn’t use spatial coherence and compare the results with those obtained here. Exercise # Implement a mosaic (or/and ascii art) visual application. Exercise # Implement a scene having the following lighting equation: a=ambient ambient4a=ambientambient4, where ambient4ambient4 is the ambient light color. It should produce something like the sketch below: Exercise # Tweak the above diffuse shader to implement a toon shading scene. It should produce something like the sketch below: Exercise # Implement a specular reflection scene producing a result like the sketch below: Exercises # Implement a scene combining ambient, diffuse and specular lights (see the local lighting equation). Consider supporting several point light sources, with attenuation factors and Phong exponents which controls the apparent smoothness of the surface. Study and implement bump mapping. See also normal mapping and parallax mapping. Study and implement reflection mapping. "},{"id":13,"href":"/showcase/docs/workshop_3/ascii_art/","title":"Ascii Art","section":"Workshop 3","content":" Ascii art # CODE const WIDTH = 630, HEIGHT = 630; const density = \u0026#34;Ñ@#W$9876543210?!abc;:+=,._ \u0026#34;; let media; let photo; // eslint-disable-next-line no-unused-vars function setup() { createCanvas(WIDTH, HEIGHT); scaleSlider = createSlider(0.1, 0.2, 0.1, 0.02); scaleSlider.position(width - 110, height - 30); scaleSlider.style(\u0026#34;width\u0026#34;, \u0026#34;100px\u0026#34;); scaleSliderLabel = createDiv(\u0026#34;Scale\u0026#34;); scaleSliderLabel.position(width - 110, height - 50); scaleSliderLabel.style(\u0026#34;color\u0026#34;, \u0026#34;#fff\u0026#34;); modeSelector = createSelect(); modeSelector.position(10, height - 40); modeSelector.option(\u0026#34;original\u0026#34;); modeSelector.option(\u0026#34;pixelated\u0026#34;); modeSelector.option(\u0026#34;colored ascii\u0026#34;); modeSelector.option(\u0026#34;ascii\u0026#34;); modeSelector.option(\u0026#34;BW\u0026#34;); modeSelector.selected(\u0026#34;ascii\u0026#34;); modeSelector.changed(() =\u0026gt; { if (modeSelector.value() === \u0026#34;original\u0026#34;) { scaleSlider.elt.min = 0.1; scaleSlider.elt.max = 1; scaleSlider.elt.step = 0.1; scaleSlider.value(1); } else { scaleSlider.elt.min = 0.1; scaleSlider.elt.max = 0.2; scaleSlider.elt.step = 0.02; scaleSlider.value(0.1); } }); // create dropdown for brightness detection mode brightnessMode = createSelect(); brightnessMode.position(10, height - 80); brightnessMode.option(\u0026#34;Component average\u0026#34;); brightnessMode.option(\u0026#34;HSV value (V)\u0026#34;); brightnessMode.option(\u0026#34;HSL lightness (L)\u0026#34;); brightnessMode.option(\u0026#34;CIELAB lightness (L*)\u0026#34;); brightnessMode.option(\u0026#34;Rec 601 Luma Y\u0026#39;\u0026#34;); brightnessMode.selected(\u0026#34;average\u0026#34;); // create dropdown to select image or video mediaType = createSelect(); mediaType.position(10, height - 120); mediaType.option(\u0026#34;image\u0026#34;); mediaType.option(\u0026#34;video\u0026#34;); mediaType.selected(\u0026#34;video\u0026#34;); video = createCapture(VIDEO); photo = loadImage(\u0026#34;/showcase/sketches/mandrill.png\u0026#34;); } // eslint-disable-next-line no-unused-vars function draw() { background(0); scale = scaleSlider.value(); if (mediaType.value() === \u0026#34;video\u0026#34;) { media = video; media.size(WIDTH * scale, HEIGHT * scale); } else { media = photo.get(); media.resize(WIDTH * scale, HEIGHT * scale); } let w = WIDTH / media.width; let h = HEIGHT / media.height; media.loadPixels(); mode = modeSelector.value(); if (mode === \u0026#34;original\u0026#34;) { image(media, 0, 0, WIDTH, HEIGHT); return; } for (let y = 0; y \u0026lt; media.height; y++) { for (let x = 0; x \u0026lt; media.width; x++) { let index = (x + y * media.width) * 4; let r = media.pixels[index]; let g = media.pixels[index + 1]; let b = media.pixels[index + 2]; if (brightnessMode.value() === \u0026#34;Component average\u0026#34;) { bright = (r + g + b) / 3; } else if (brightnessMode.value() === \u0026#34;HSV value (V)\u0026#34;) { bright = RGBtoHSV(r, g, b)[2]; } else if (brightnessMode.value() === \u0026#34;HSL lightness (L)\u0026#34;) { bright = RGBtoHSL(r, g, b)[2]; } else if (brightnessMode.value() === \u0026#34;CIELAB lightness (L*)\u0026#34;) { bright = CIELAB(r, g, b)[0]; } else if (brightnessMode.value() === \u0026#34;Rec 601 Luma Y\u0026#39;\u0026#34;) { bright = 0.299 * r + 0.587 * g + 0.114 * b; } let charIndex = Math.floor(map(bright, 0, 255, density.length, 0)); let char = density.charAt(charIndex); noStroke(); if (mode === \u0026#34;ascii\u0026#34;) { fill(255); textSize(w); textAlign(CENTER, CENTER); text(char, x * w + w * 0.5, y * h + h * 0.5); } else if (mode === \u0026#34;pixelated\u0026#34;) { fill(r, g, b); rect(x * w, y * h, w, h); } else if (mode === \u0026#34;colored ascii\u0026#34;) { fill(r, g, b); textSize(w); textAlign(CENTER, CENTER); text(char, x * w + w * 0.5, y * h + h * 0.5); } else if (mode === \u0026#34;BW\u0026#34;) { fill(bright); rect(x * w, y * h, w, h); } } } } GUI # The GUI has 3 dropdowns and a slider.\nThe first dropdown is for media type, it can be a video or an image. The second dropdown is for the brightness method. The render mode, it may be the original or the ascii version. The slider is for the scaling of the image.\nCharacters # \u0026#39;Ñ@#W$9876543210?!abc;:+=,._ \u0026#39; This is the order of characters used for the brightness of each pixel.\nIt may be interpreted as brightest to darkest, or darkest to brightest, depending on the background vs foreground colors.\nThe last character is a space representing an empty pixel in the ascii art.\nPixelation # The pixelation mode is the simplest one, it just maps the pixels of the image to the pixels of the canvas. It doesn\u0026rsquo;t have spatial coherence so there is some loss in the contour of the image.\nBrightness # The brightness of each pixel is calculated using the selected method.\nThe brightness is then mapped to the characters, from the darkest to the brightest.\nComponent average\nThe brightness is calculated using the average of the RGB components.\nbright = (r + g + b) / 3; HSV value (V)\nbright = RGBtoHSV(r, g, b)[2]; RGBtoHSV function RGBtoHSV(r, g, b) { let h, s, v; let min, max, delta; min = Math.min(r, g, b); max = Math.max(r, g, b); v = max; delta = max - min; if (max != 0) s = delta / max; else { s = 0; h = -1; return [h, s, v]; } if (r == max) h = (g - b) / delta; else if (g == max) h = 2 + (b - r) / delta; else h = 4 + (r - g) / delta; h *= 60; if (h \u0026lt; 0) h += 360; return [h, s, v]; } HSL lightness (L)\nbright = RGBtoHSL(r, g, b)[2]; RGBtoHSL function RGBtoHSL(r, g, b) { let h, s, l; let min, max, delta; min = Math.min(r, g, b); max = Math.max(r, g, b); l = (min + max) / 2; delta = max - min; if (max == min) { s = 0; h = 0; } else { if (l \u0026lt; 0.5) s = delta / (max + min); else s = delta / (2 - max - min); if (r == max) h = (g - b) / delta; else if (g == max) h = 2 + (b - r) / delta; else h = 4 + (r - g) / delta; h *= 60; if (h \u0026lt; 0) h += 360; } return [h, s, l]; } CIELAB lightness (L*)\nbright = CIELAB(r, g, b)[0]; CIELAB // CIELAB lightness (L*) calculation using RGB values function CIELAB(r, g, b) { let R = r / 255; let G = g / 255; let B = b / 255; if (R \u0026gt; 0.04045) R = Math.pow((R + 0.055) / 1.055, 2.4); else R = R / 12.92; if (G \u0026gt; 0.04045) G = Math.pow((G + 0.055) / 1.055, 2.4); else G = G / 12.92; if (B \u0026gt; 0.04045) B = Math.pow((B + 0.055) / 1.055, 2.4); else B = B / 12.92; R = R * 100; G = G * 100; B = B * 100; let X = R * 0.4124 + G * 0.3576 + B * 0.1805; let Y = R * 0.2126 + G * 0.7152 + B * 0.0722; let Z = R * 0.0193 + G * 0.1192 + B * 0.9505; X = X / 95.047; Y = Y / 100.0; Z = Z / 108.883; if (X \u0026gt; 0.008856) X = Math.pow(X, 1 / 3); else X = 7.787 * X + 16 / 116; if (Y \u0026gt; 0.008856) Y = Math.pow(Y, 1 / 3); else Y = 7.787 * Y + 16 / 116; if (Z \u0026gt; 0.008856) Z = Math.pow(Z, 1 / 3); else Z = 7.787 * Z + 16 / 116; let L = 116 * Y - 16; let A = 500 * (X - Y); let B_ = 200 * (Y - Z); return [L, A, B_]; } "},{"id":14,"href":"/showcase/docs/workshop_3/coloring/","title":"Coloring","section":"Workshop 3","content":" Shaders - Coloring # CMY and RGB Color Models # Explicación # CODE cmy = false function setup() { // shaders require WEBGL mode to work createCanvas(400, 400, WEBGL); setColor(); randomizeTriangle(); } function draw() { background(0); beginShape(TRIANGLES); fill(r); vertex(v1.x*200, v1.y*200); fill(g); vertex(v2.x*200, v2.y*200); fill(b); vertex(v3.x*200, v3.y*200); endShape(); } function keyPressed() { if (key == \u0026#39;c\u0026#39;) { cmy = !cmy; setColor(); console.log(cmy) } if (key == \u0026#39;r\u0026#39;) { randomizeTriangle(); } } function randomizeTriangle(){ v1 = p5.Vector.random2D(); v2 = p5.Vector.random2D(); v3 = p5.Vector.random2D(); } function setColor(){ if(cmy){ r = color(0,255,255); g = color(255,0,255); b = color(255,255,0); } else{ r = color(255,0,0); g = color(0,255,0); b = color(0,0,255); } } Color Blending # Explicación # CODE let colorPicker1; let colorPicker2; function setup() { // shaders require WEBGL mode to work createCanvas(400, 400, WEBGL); color1 = color(55,58,164); color2 = color(200,0,255); colorPicker1 = createColorPicker(color1); colorPicker1.position(10, 10); colorPicker2 = createColorPicker(color2); colorPicker2.position(200, 10); } function draw() { background(0); color1 = colorPicker1.color(); beginShape(QUADS); noStroke(); fill(color1) vertex(-170, -180); vertex(-170, -40); vertex(-30, -40); vertex(-30, -180); endShape(); color2 = colorPicker2.color(); beginShape(QUADS); noStroke(); fill(color2) vertex(20, -180); vertex(20, -40); vertex(160, -40); vertex(160, -180); endShape(); print(color1) v1 = createVector(red(color1), green(color1), blue(color1)) v2 = createVector(red(color2), green(color2), blue(color2)) v3 = p5.Vector.mult(v1,v2) fill(v3.x/255,v3.y/255,v3.z/255) beginShape(QUADS); vertex(-75, 20); vertex(-75, 160); vertex(65, 160); vertex(65, 20); endShape(); } Color Blending With brightness # Explicación # CODE let colorPicker1; let colorPicker2; function setup() { createCanvas(400, 400); color1 = color(55,58,164); color2 = color(200,0,255); colorPicker1 = createColorPicker(color1); colorPicker1.position(10, 10); colorPicker2 = createColorPicker(color2); colorPicker2.position(200, 10); lightSlider = createSlider(0, 255, 255, 1); lightSlider.position(130, 180); } function draw() { background(0); color1 = colorPicker1.color(); beginShape(QUADS); noStroke(); fill(color1) vertex(30, 20); vertex(30, 160); vertex(170, 160); vertex(170, 20); endShape(); color2 = colorPicker2.color(); beginShape(QUADS); noStroke(); fill(color2) vertex(220, 20); vertex(220, 160); vertex(360, 160); vertex(360, 20); endShape(); print(color1) v1 = createVector(red(color1), green(color1), blue(color1)) v2 = createVector(red(color2), green(color2), blue(color2)) v3 = p5.Vector.mult(v1,v2) fill(v3.x/255,v3.y/255,v3.z/255, lightSlider.value()) beginShape(QUADS); vertex(125, 220); vertex(125, 360); vertex(265, 360); vertex(265, 220); endShape(); } "},{"id":15,"href":"/showcase/docs/workshop_3/image_processing/","title":"Image Processing","section":"Workshop 3","content":" Image Processing # Exercise # Implement an image / video processing app supporting different masks, including other kernel sizes different than 3x3, and:\nA region-of-interest base tool to selectively apply a given mask.Hint: circular regions around the mouse pointer are handy and quite simple to implement by means of glsl distance. A magnifier tool. Requires a bit of research. For instance, look for it in shadertoy. Integrate luma and other coloring brightness tools. What other shader tools would you implement?\nKernel # In image processing, a kernel, convolution matrix, or mask is a small matrix used for blurring, sharpening, embossing, edge detection, and more. This is accomplished by doing a convolution between the kernel and an image.\nConvolution # Convolution is the process of adding each element of the image to its local neighbors, weighted by the kernel. This is related to a form of mathematical convolution. The matrix operation being performed—convolution—is not traditional matrix multiplication, despite being similarly denoted by *.\nFor each 3x3 block of pixels in the original image , we multiply each pixel by the corresponding entry of the kernel and then take the sum. That sum becomes a new pixel in the result image.\nOne subtlety of this process is what to do along the edges of the image. For example, the top left corner of the input image only has three neighbors. One way to fix this is to extend the edge values out by one in the original image while keeping our new image the same size.\nKernels # KERNELS BOX BLUR:\n\\( \\frac{1}{9} \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1\\\\ 1 \u0026amp; 1 \u0026amp; 1 \\end{bmatrix} \\) SHARPEN KERNEL:\n\\( \\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 5 \u0026amp; -1\\\\ 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\) OUTLINE KERNEL:\n\\( \\begin{bmatrix} -1 \u0026amp; -1 \u0026amp; -1\\\\ -1 \u0026amp; 8 \u0026amp; -1\\\\ -1 \u0026amp; -1 \u0026amp; -1 \\end{bmatrix} \\) EMBOSS KERNEL:\n\\( \\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 1 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 2 \\end{bmatrix} \\) EDGE KERNEL:\n\\( \\begin{bmatrix} -1 \u0026amp; -2 \u0026amp; -1\\\\ -1 \u0026amp; 8 \u0026amp; -1\\\\ -1 \u0026amp; -4 \u0026amp; -1 \\end{bmatrix} \\) Results # KERNEL vec4 applyKernel(){ vec2 tc0 = texcoords2 + vec2(-texOffset.s, -texOffset.t); vec2 tc1 = texcoords2 + vec2( 0.0, -texOffset.t); vec2 tc2 = texcoords2 + vec2(+texOffset.s, -texOffset.t); vec2 tc3 = texcoords2 + vec2(-texOffset.s, 0.0); vec2 tc4 = texcoords2 + vec2( 0.0, 0.0); vec2 tc5 = texcoords2 + vec2(+texOffset.s, 0.0); vec2 tc6 = texcoords2 + vec2(-texOffset.s, +texOffset.t); vec2 tc7 = texcoords2 + vec2( 0.0, +texOffset.t); vec2 tc8 = texcoords2 + vec2(+texOffset.s, +texOffset.t); vec4 rgba[9]; rgba[0] = texture2D(texture, tc0); rgba[1] = texture2D(texture, tc1); rgba[2] = texture2D(texture, tc2); rgba[3] = texture2D(texture, tc3); rgba[4] = texture2D(texture, tc4); rgba[5] = texture2D(texture, tc5); rgba[6] = texture2D(texture, tc6); rgba[7] = texture2D(texture, tc7); rgba[8] = texture2D(texture, tc8); vec4 convolution; for (int i = 0; i \u0026lt; 9; i++) { convolution += rgba[i]*kernel[i]; } convolution = vec4(convolution.rgb, 1.0); return convolution; } MAGNIFIER - REGION if(dist \u0026lt; radius){ if(magnifier){ vec2 mouseDist = gl_FragCoord.xy - mouse; vec2 newCoords = gl_FragCoord.xy; vec2 zoomed = (newCoords - (mouseDist * scale)) / resolution; zoomed = vec2(zoomed.x, 1.0 - zoomed.y); vec4 zoomedTexel = texture2D(texture, zoomed); zoomedTexel = changeBrightness(zoomedTexel); gl_FragColor = zoomedTexel; } else if(region){ vec2 newCoords = gl_FragCoord.xy; vec2 region = newCoords / resolution; vec4 regionTexel = texture2D(texture, region); regionTexel = applyKernel(); regionTexel = changeBrightness(regionTexel); gl_FragColor = regionTexel; } else{ gl_FragColor = texel; } } else{ gl_FragColor = texel; } BRIGHT float luma(vec3 texel){ return 0.299 * texel.r + 0.587 * texel.g + 0.114 * texel.b; } float hsv(vec3 texel){ return max(max(texel.r, texel.g), texel.b); } float hsl(vec3 texel){ float maxColor = max(max(texel.r, texel.g), texel.b); float minColor = min(min(texel.r, texel.g), texel.b); return (maxColor + minColor)/2.0; } "},{"id":16,"href":"/showcase/docs/workshop_3/video_pixelator/","title":"Video Pixelator","section":"Workshop 3","content":" Video Circle Pixelator # A pixel is generally thought of as the smallest single component of a digital image. However, the definition is highly context-sensitive. For example, there can be \u0026ldquo;printed pixels\u0026rdquo; in a page, or pixels carried by electronic signals, or represented by digital values, or pixels on a display device, or pixels in a digital camera (photosensor elements). This list is not exhaustive and, depending on context, synonyms include pel, sample, byte, bit, dot, and spot. Pixels can be used as a unit of measure such as: 2400 pixels per inch, 640 pixels per line, or spaced 10 pixels apart.\n"}]